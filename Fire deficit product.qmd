---
title: "Fire deficit product"
format: docx
editor: source
author: Lora Murphy
date: today
output-file: "Fire deficit product"
---

```{r setup, include=FALSE}
library(terra)
library(sf)
library(kableExtra)
library(ggplot2)
library(exactextractr)
library(tidyverse)
library(tidyterra)
library(patchwork)
library(gpkg)
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(messages = FALSE)
knitr::opts_chunk$set(warnings = FALSE)
knitr::opts_chunk$set(results = 'asis')
#\options(knitr.table.format = "latex")
terraOptions(tempdir="D:/workspace/Lora/temp") # Terminator
#terraOptions(tempdir="D:/Lora/temp") # Groot
```

# SPARKs

We want summary statistics on fire deficit for SPARK watershed regions. To produce these statistics, I used rasterized values of fire deficit where possible, in frequent fire areas. Areas in less-frequent fire areas (FRI > 40) received the value of the ecoregion-level deficit. There are different ecoregion-level deficit values for forest, grasslands, and shrublands (see later in this document for details) and the appropriate value was used for each vegetation type.

```{r regions-prep}
#| eval: false

#-----------------------------------------------------------------------------#
# PLEASE NOTE:
# These chunks are now out of order overall. SPARK stuff must be run after the
# raster production later in this document (all marked to eval: false). This
# is rearranged so I can show the latest results first.
#-----------------------------------------------------------------------------#
fri <- terra::rast("../temp_rasters/all_fri_vals.tif")
veg <- terra::rast("../temp_rasters/combined_veg_area.tif")
wui <- terra::rast("../temp_rasters/wui.tif")

#----- Load SPARK watersheds -------------------------------------------------#
spark <- terra::vect("../../Spark counties shapefile/spark_watersheds.shp")
spark <- terra::project(spark, fri)

#----- Load states -----------------------------------------------------------#
states <- terra::vect("../Data/s_05mr24.shp")
states <- terra::project(states, fri)
states <- terra::crop(states, fri)

#----- Some common aesthetics for plotting -----------------------------------#
blank_axes <- theme(axis.title.x=element_blank(),
                    axis.text.x=element_blank(),
                    axis.ticks.x=element_blank(),
                    axis.title.y=element_blank(),
                    axis.text.y=element_blank(),
                    axis.ticks.y=element_blank(),
                    panel.border = element_blank())

fri_scale <- scale_fill_grass_c(na.value = NA, name="Years")
veg_scale <- scale_fill_manual(values = 
                                 c("darkgreen", 
                                   "darkgoldenrod3", 
                                   "burlywood4"), 
                               name = "",
                               na.translate=F)
forest_type_scale <- 
  scale_fill_grass_d(name = "", na.translate = FALSE,
                     labels = c("Frequent fire \n(FRI < 20)", 
                                "Frequent fire \n(FRI 20-40)", 
                                "Infrequent fire"))
deficit_scale <- scale_fill_grass_c(na.value = NA, name="Deficit < 0")

#----- Load ecoregions with long-term FRI ------------------------------------#
long_forst_def <- terra::rast("../temp_rasters/eco_forest_def.tif")
long_grass_def <- terra::rast("../temp_rasters/eco_grass_def.tif")
long_shrub_def <- terra::rast("../temp_rasters/eco_shrub_def.tif")

short_def <- terra::rast("../western_us_fire_deficit.tif")


ha_to_acres <- 2.47105

#plot(eco,range=c(-1,10),fill_range=T)
```

```{r do-a-region}
#| eval: false

do_a_region <- function(region_name, region_shape) {
  
  #---------------------------------------------------------------------------#
  # Make a nice map of all vegetation and FRI to amuse the reader
  #---------------------------------------------------------------------------#
  
  #----- Clip FRI and display ------------------------------------------------#
  fri_crop <- terra::crop(fri     , region_shape)
  fri_crop <- terra::mask(fri_crop, region_shape)
  
  #plot(fri_crop)
  
  suppressMessages(fri_plot <- ggplot() + 
                     geom_spatraster(data = fri_crop) +
                     geom_spatvector(data = region_shape, fill=NA) +
                     theme_bw() +
                     blank_axes +
                     ggtitle("Fire return interval") +
                     fri_scale)
  
  #----- Clip veg and display ------------------------------------------------#
  veg_crop <- terra::crop(veg     , region_shape)
  veg_crop <- terra::mask(veg_crop, region_shape)
  
  
  suppressMessages(veg_map_plot <- ggplot() + 
                     geom_spatraster(data = veg_crop) +
                     geom_spatvector(data = region_shape, fill=NA) +
                     theme_bw() +
                     blank_axes +
                     ggtitle("Vegetation map") +
                     veg_scale)
  
  #----- Clip WUI ------------------------------------------------------------#
  wui_crop <- terra::crop(wui     , region_shape)
  wui_crop <- terra::mask(wui_crop, region_shape)
  #---------------------------------------------------------------------------#
  
  
  
  #---------------------------------------------------------------------------#
  # Forests.
  # Frequent fire forests FRI 0-20 years
  # Frequent fire forest FRI 20-40
  # Infrequent fire forests (FRI > 40)
  #---------------------------------------------------------------------------#
  #cat("## Forest area\n\n")
  
  #----- ID forests by fire frequency ----------------------------------------#
  forest_mask <- terra::ifel(veg_crop == "Forest", 1, NA)
  forest_fri <- terra::mask(fri_crop, forest_mask)
  
  forest_mat <- cbind(c(0,20,40), c(20, 40, 100000), 1:3)
  forest_type <- terra::classify(forest_fri, forest_mat)
  levels(forest_type) <- data.frame(ID = 1:3, 
                                    category = c(
                                      "Frequent fire (FRI < 20)", 
                                      "Frequent fire (FRI 20-40)", 
                                      "Infrequent fire"))
  rm(forest_fri, forest_mask)
  invisible(gc())
  
  
  #----- Make a total fire deficit map, including long deficit ---------------#
  long_crop <- terra::crop(long_forst_def, region_shape)
  long_crop <- terra::mask(long_crop     , region_shape)
  
  short_crop <- terra::crop(short_def , region_shape)
  short_crop <- terra::crop(short_crop, region_shape)
  
  #----- I want to only substitute eco-level deficit where there isn't short -#
  long_crop <- terra::mask(long_crop, short_crop, inverse = T)
  all_def <- terra::subst(long_crop, NA, 0) + terra::subst(short_crop, NA, 0)
  rm(short_crop, long_crop)
  invisible(gc())
  #----- Mask back to FRI, no values if FRI was NA ---------------------------#
  all_def <- terra::mask(all_def, fri_crop)
  all_def <- terra::mask(all_def, forest_type)
  
  #---------------------------------------------------------------------------#
  # Entertain the reader with maps of forest type and deficit
  #---------------------------------------------------------------------------#
  suppressMessages(forest_types_plot <- ggplot() + 
                     geom_spatraster(data = forest_type) +
                     geom_spatvector(data = region_shape, fill=NA) +
                     theme_bw() +
                     blank_axes +
                     #theme(legend.position = "bottom") +
                     guides(fill = guide_legend(nrow = 3)) +
                     ggtitle("Forest types") +
                     forest_type_scale)
  
  lims <- range(values(all_def), na.rm = T)
  if (abs(lims[1]/lims[2]) > 1.5 || abs(lims[1]/lims[2]) < 0.75) {
    threshold <- ceiling(min(abs(lims)))
    breaks <- round(c(seq(from=-threshold, to=0, length=3),
                seq(from=0, to = threshold, length=3)[2:3]), 0)
    labels <- c(paste("<", breaks[1]), breaks[2:4], paste(">", breaks[5]))
    deficit_scale <- scale_fill_grass_c(na.value = NA, name="Deficit < 0",
                       limits = c(-threshold, threshold),
                       breaks = breaks,
                       labels = labels,
                       oob = scales::squish) 
  } else {
    deficit_scale <- scale_fill_grass_c(na.value = NA, name="Deficit < 0")
  }
    
  suppressMessages(fire_def_plot <- ggplot() + 
                     geom_spatraster(data = all_def) +
                     geom_spatvector(data = region_shape, fill=NA) +
                     theme_bw() +
                     blank_axes +
                     ggtitle("Forests fire deficit/surplus") +
                     deficit_scale)
  
  #---------------------------------------------------------------------------#
  # Extract table stats
  #---------------------------------------------------------------------------#
  
  #----- Overall area --------------------------------------------------------#
  vv <- values(forest_type)
  tab <- table(vv)
  
  summary_dat <- data.frame(Forest = levels(forest_type)[[1]]$category,
                            Numcells = as.numeric(unlist(tab)))
  rm(vv, tab)
  invisible(gc())
  
  #----- Area in surplus and deficit -----------------------------------------#
  surplus <- terra::ifel(all_def > 0, 1, 0)
  datum <- terra::zonal(surplus, forest_type, fun="sum")
  if (identical(as.character(datum$category), summary_dat$Forest)) {
    summary_dat$Numsurpluscells <- datum$forest_def
  } else {
    stop("heeeeeelp")
  }
  rm(surplus)
  invisible(gc())
  
  deficit <- terra::ifel(all_def < 0, 1, 0)
  datum <- terra::zonal(deficit, forest_type, fun="sum")
  if (identical(as.character(datum$category), summary_dat$Forest)) {
    summary_dat$Numdeficitcells <- datum$forest_def
  } else {
    stop("heeeeeelp")
  }
  rm(deficit)
  invisible(gc())
  
  #----- Mean and sd of deficit ----------------------------------------------#
  datum <- terra::zonal(all_def, forest_type, fun="mean")
  if (identical(as.character(datum$category), summary_dat$Forest)) {
    summary_dat$mean_deficit <- datum$forest_def
  } else {
    stop("heeeeeelp")
  }
  
  datum <- terra::zonal(all_def, forest_type, fun="sd")
  if (identical(as.character(datum$category), summary_dat$Forest)) {
    summary_dat$sd_deficit <- datum$forest_def
  } else {
    stop("heeeeeelp")
  }
  
  #---------------------------------------------------------------------------#
  # Forest WUI 
  #---------------------------------------------------------------------------#
  summary_dat <- rbind(summary_dat, 
                       data.frame(Forest = c("Forest WUI", "Forest non-WUI"),
                                  Numcells = 0, Numsurpluscells = 0, 
                                  Numdeficitcells = 0, mean_deficit = 0,
                                  sd_deficit = 0))
  
  #----- Overall forest WUI area ---------------------------------------------#
  datum <- mask(wui_crop, forest_type)
  summary_dat$Numcells[summary_dat$Forest == "Forest WUI"] <- sum(!is.na(values(datum)), na.rm=T)
  datum <- mask(forest_type, wui_crop, inverse=T)
  summary_dat$Numcells[summary_dat$Forest == "Forest non-WUI"] <- sum(!is.na(values(datum)), na.rm=T)
  rm(datum)
  invisible(gc())
  
  #----- Area in surplus and deficit -----------------------------------------#
  surplus <- terra::ifel(all_def > 0, 1, NA)
  surp <- terra::mask(surplus, wui_crop)
  summary_dat$Numsurpluscells[summary_dat$Forest == "Forest WUI"] <- sum(values(surp), na.rm=T)
  surp <- terra::mask(surplus, wui_crop, inverse = T)
  summary_dat$Numsurpluscells[summary_dat$Forest == "Forest non-WUI"] <- sum(values(surp), na.rm=T)
  
  rm(surplus, surp)
  invisible(gc())
  
  deficit <- terra::ifel(all_def < 0, 1, NA)
  defr <- terra::mask(deficit, wui_crop)
  summary_dat$Numdeficitcells[summary_dat$Forest == "Forest WUI"] <- sum(values(defr), na.rm=T)
  defr <- terra::mask(deficit, wui_crop, inverse = T)
  summary_dat$Numdeficitcells[summary_dat$Forest == "Forest non-WUI"] <- sum(values(defr), na.rm=T)
  rm(deficit, defr)
  invisible(gc())
  
  #----- Mean and sd of deficit ----------------------------------------------#
  defr <- terra::mask(all_def, wui_crop)
  summary_dat$mean_deficit[summary_dat$Forest == "Forest WUI"] <- mean(values(defr), na.rm=T)
  summary_dat$sd_deficit  [summary_dat$Forest == "Forest WUI"] <- sd(values(defr), na.rm=T)
  
  defr <- terra::mask(all_def, wui_crop, inverse=T)
  summary_dat$mean_deficit[summary_dat$Forest == "Forest non-WUI"] <- mean(values(defr), na.rm=T)
  summary_dat$sd_deficit  [summary_dat$Forest == "Forest non-WUI"] <- sd(values(defr), na.rm=T)
  
  #----- Clean up and get ready to display -----------------------------------#
  summary_dat$Total_area <- 
    ((summary_dat$Numcells * prod(res(forest_type)))/10000) * ha_to_acres
  
  summary_dat$Surplus_area <- 
    ((summary_dat$Numsurpluscells * prod(res(forest_type)))/10000) * ha_to_acres
  
  summary_dat$Deficit_area <- 
    ((summary_dat$Numdeficitcells * prod(res(forest_type)))/10000) * ha_to_acres
  
  summary_dat$Numcells <- NULL
  summary_dat$Numdeficitcells <- NULL
  summary_dat$Numsurpluscells <- NULL
  
  rm(forest_type)
  invisible(gc())
  
  
  
  #---------------------------------------------------------------------------#
  # Grass
  #---------------------------------------------------------------------------#
  grass_mask <- terra::ifel(veg_crop == "Grass", 1, NA)
  #grass_fri  <- terra::mask(fri_crop, grass_mask)
  
  #----- Make a total fire deficit map, including long deficit ---------------#
  long_crop <- terra::crop(long_grass_def, region_shape)
  long_crop <- terra::mask(long_crop     , region_shape)
  
  short_crop <- terra::crop(short_def , region_shape)
  short_crop <- terra::crop(short_crop, region_shape)
  
  #----- I want to only substitute eco-level deficit where there isn't short -#
  long_crop <- terra::mask(long_crop, short_crop, inverse = T)
  all_def <- terra::subst(long_crop, NA, 0) + terra::subst(short_crop, NA, 0)
  rm(short_crop, long_crop)
  invisible(gc())
  #----- Mask back to FRI, no values if FRI was NA ---------------------------#
  all_def <- terra::mask(all_def, fri_crop)
  all_def <- terra::mask(all_def, grass_mask)
  #---------------------------------------------------------------------------#
  
  
  
  #----- Prep a map of grass deficit -----------------------------------------#
  
   lims <- range(values(all_def), na.rm = T)
  if (abs(lims[1]/lims[2]) > 1.5 || abs(lims[1]/lims[2]) < 0.75) {
    threshold <- ceiling(min(abs(lims)))
    breaks <- round(c(seq(from=-threshold, to=0, length=3),
                seq(from=0, to = threshold, length=3)[2:3]), 0)
    labels <- c(paste("<", breaks[1]), breaks[2:4], paste(">", breaks[5]))
    deficit_scale <- scale_fill_grass_c(na.value = NA, name="Deficit < 0",
                       limits = c(-threshold, threshold),
                       breaks = breaks,
                       labels = labels,
                       oob = scales::squish) 
  } else {
    deficit_scale <- scale_fill_grass_c(na.value = NA, name="Deficit < 0")
  }
   
  suppressMessages(grassplot <- ggplot() + 
                     geom_spatraster(data = all_def) +
                     geom_spatvector(data = region_shape, fill=NA) +
                     theme_bw() +
                     blank_axes +
                     #theme(legend.position = "bottom") +
                     ggtitle("Grass deficit/surplus") +
                     deficit_scale)
  #---------------------------------------------------------------------------#
  
  
  #----- Extract table stats -------------------------------------------------#
  
  # Overall area
  vv <- values(grass_mask)
  grass_cells <- sum(vv, na.rm=T)
  
  rm(vv)
  invisible(gc())
  
  #----- Area in surplus and deficit -----------------------------------------#
  surplus <- terra::ifel(all_def > 0, 1, 0)
  vv <- values(surplus)
  surplus_cells <- sum(vv, na.rm=T)
  rm(surplus, vv)
  
  deficit <- terra::ifel(all_def < 0, 1, 0)
  vv <- values(deficit)
  deficit_cells <- sum(vv, na.rm=T)
  rm(deficit, vv)
  invisible(gc())
  
  #----- Mean and sd of deficit ----------------------------------------------#
  vv <- values(all_def)
  mean_deficit <- mean(vv, na.rm=T)
  sd_deficit   <- sd  (vv, na.rm=T)
  
  summary_dat <- rbind(summary_dat, data.frame(
    Forest = "Grassland",
    Total_area = ((grass_cells * prod(res(grass_mask)))/10000) * ha_to_acres,
    Surplus_area = ((surplus_cells * prod(res(grass_mask)))/10000) * ha_to_acres,
    Deficit_area = ((deficit_cells * prod(res(grass_mask)))/10000) * ha_to_acres,
    mean_deficit = mean_deficit,
    sd_deficit = sd_deficit
  ))
  
  #---------------------------------------------------------------------------#
  # Grass WUI 
  #---------------------------------------------------------------------------#
  summary_dat <- rbind(summary_dat, 
                       data.frame(Forest = c("Grass WUI", "Grass non-WUI"),
                                  Total_area = 0, Surplus_area = 0, 
                                  Deficit_area = 0, mean_deficit = 0,
                                  sd_deficit = 0))
  
  #----- Overall grass WUI area ---------------------------------------------#
  datum <- mask(grass_mask, wui_crop)
  numcells <- sum(!is.na(values(datum)), na.rm=T)
  summary_dat$Total_area[summary_dat$Forest == "Grass WUI"] <- ((numcells * prod(res(grass_mask)))/10000) * ha_to_acres
  datum <- mask(grass_mask, wui_crop, inverse=T)
  numcells <- sum(!is.na(values(datum)), na.rm=T)
  summary_dat$Total_area[summary_dat$Forest == "Grass non-WUI"] <- ((numcells * prod(res(grass_mask)))/10000) * ha_to_acres
  rm(datum)
  invisible(gc())
  
  #----- Area in surplus and deficit -----------------------------------------#
  surplus <- terra::ifel(all_def > 0, 1, NA)
  surp <- terra::mask(surplus, wui_crop)
  numcells <- sum(values(surp), na.rm=T)
  summary_dat$Surplus_area[summary_dat$Forest == "Grass WUI"] <- ((numcells * prod(res(grass_mask)))/10000) * ha_to_acres
  surp <- terra::mask(surplus, wui_crop, inverse = T)
  numcells <- sum(values(surp), na.rm=T)
  summary_dat$Surplus_area[summary_dat$Forest == "Grass non-WUI"] <- ((numcells * prod(res(grass_mask)))/10000) * ha_to_acres
  
  rm(surplus, surp)
  invisible(gc())
  
  deficit <- terra::ifel(all_def < 0, 1, NA)
  defr <- terra::mask(deficit, wui_crop)
  numcells <- sum(values(defr), na.rm=T)
  summary_dat$Deficit_area[summary_dat$Forest == "Grass WUI"] <- ((numcells * prod(res(grass_mask)))/10000) * ha_to_acres
  defr <- terra::mask(deficit, wui_crop, inverse = T)
  numcells <- sum(values(defr), na.rm=T)
  summary_dat$Deficit_area[summary_dat$Forest == "Grass non-WUI"] <- ((numcells * prod(res(grass_mask)))/10000) * ha_to_acres
  rm(deficit, defr)
  invisible(gc())
  
  #----- Mean and sd of deficit ----------------------------------------------#
  defr <- terra::mask(all_def, wui_crop)
  summary_dat$mean_deficit[summary_dat$Forest == "Grass WUI"] <- mean(values(defr), na.rm=T)
  summary_dat$sd_deficit  [summary_dat$Forest == "Grass WUI"] <- sd(values(defr), na.rm=T)
  
  defr <- terra::mask(all_def, wui_crop, inverse=T)
  summary_dat$mean_deficit[summary_dat$Forest == "Grass non-WUI"] <- mean(values(defr), na.rm=T)
  summary_dat$sd_deficit  [summary_dat$Forest == "Grass non-WUI"] <- sd(values(defr), na.rm=T)
  
  rm(grass_mask, vv, all_def)
  invisible(gc())
  #---------------------------------------------------------------------------#
  
  
  
  #---------------------------------------------------------------------------#
  # Shrub
  #---------------------------------------------------------------------------#
  shrub_mask <- terra::ifel(veg_crop == "Shrub", 1, NA)
  
  #----- Make a total fire deficit map, including long deficit ---------------#
  long_crop <- terra::crop(long_shrub_def, region_shape)
  long_crop <- terra::mask(long_crop     , region_shape)
  
  short_crop <- terra::crop(short_def , region_shape)
  short_crop <- terra::crop(short_crop, region_shape)
  
  #----- I want to only substitute eco-level deficit where there isn't short -#
  long_crop <- terra::mask(long_crop, short_crop, inverse = T)
  all_def <- terra::subst(long_crop, NA, 0) + terra::subst(short_crop, NA, 0)
  rm(short_crop, long_crop)
  invisible(gc())
  #----- Mask back to FRI, no values if FRI was NA ---------------------------#
  all_def <- terra::mask(all_def, fri_crop)
  all_def <- terra::mask(all_def, shrub_mask)
  #---------------------------------------------------------------------------#
  
  
  
  #----- Prep a map of shrub deficit -----------------------------------------#
   lims <- range(values(all_def), na.rm = T)
  if (abs(lims[1]/lims[2]) > 1.5 || abs(lims[1]/lims[2]) < 0.75) {
    threshold <- ceiling(min(abs(lims)))
    breaks <- round(c(seq(from=-threshold, to=0, length=3),
                seq(from=0, to = threshold, length=3)[2:3]), 0)
    labels <- c(paste("<", breaks[1]), breaks[2:4], paste(">", breaks[5]))
    deficit_scale <- scale_fill_grass_c(na.value = NA, name="Deficit < 0",
                       limits = c(-threshold, threshold),
                       breaks = breaks,
                       labels = labels,
                       oob = scales::squish) 
  } else {
    deficit_scale <- scale_fill_grass_c(na.value = NA, name="Deficit < 0")
  }
   
  suppressMessages(shrubplot <- ggplot() + 
                     geom_spatraster(data = all_def) +
                     geom_spatvector(data = region_shape, fill=NA) +
                     theme_bw() +
                     blank_axes +
                     #theme(legend.position = "bottom") +
                     ggtitle("Shrub deficit/surplus") +
                     deficit_scale)
  #---------------------------------------------------------------------------#
  
  
  #----- Extract table stats -------------------------------------------------#
  
  # Overall area
  vv <- values(shrub_mask)
  shrub_cells <- sum(vv, na.rm=T)
  
  rm(vv)
  invisible(gc())
  
  #----- Area in surplus and deficit -----------------------------------------#
  surplus <- terra::ifel(all_def > 0, 1, 0)
  vv <- values(surplus)
  surplus_cells <- sum(vv, na.rm=T)
  rm(surplus, vv)
  
  deficit <- terra::ifel(all_def < 0, 1, 0)
  vv <- values(deficit)
  deficit_cells <- sum(vv, na.rm=T)
  rm(deficit, vv)
  invisible(gc())
  
  #----- Mean and sd of deficit ----------------------------------------------#
  vv <- values(all_def)
  mean_deficit <- mean(vv, na.rm=T)
  sd_deficit   <- sd  (vv, na.rm=T)
  
  summary_dat <- rbind(summary_dat, data.frame(
    Forest = "Shrubland",
    Total_area = ((shrub_cells * prod(res(shrub_mask)))/10000) * ha_to_acres,
    Surplus_area = ((surplus_cells * prod(res(shrub_mask)))/10000) * ha_to_acres,
    Deficit_area = ((deficit_cells * prod(res(shrub_mask)))/10000) * ha_to_acres,
    mean_deficit = mean_deficit,
    sd_deficit = sd_deficit
  ))
  
  #---------------------------------------------------------------------------#
  # Shrub WUI 
  #---------------------------------------------------------------------------#
  summary_dat <- rbind(summary_dat, 
                       data.frame(Forest = c("Shrub WUI", "Shrub non-WUI"),
                                  Total_area = 0, Surplus_area = 0, 
                                  Deficit_area = 0, mean_deficit = 0,
                                  sd_deficit = 0))
  
  #----- Overall Shrub WUI area ---------------------------------------------#
  datum <- mask(shrub_mask, wui_crop)
  numcells <- sum(!is.na(values(datum)), na.rm=T)
  summary_dat$Total_area[summary_dat$Forest == "Shrub WUI"] <- ((numcells * prod(res(shrub_mask)))/10000) * ha_to_acres
  datum <- mask(shrub_mask, wui_crop, inverse=T)
  numcells <- sum(!is.na(values(datum)), na.rm=T)
  summary_dat$Total_area[summary_dat$Forest == "Shrub non-WUI"] <- ((numcells * prod(res(shrub_mask)))/10000) * ha_to_acres
  rm(datum)
  invisible(gc())
  
  #----- Area in surplus and deficit -----------------------------------------#
  surplus <- terra::ifel(all_def > 0, 1, NA)
  surp <- terra::mask(surplus, wui_crop)
  numcells <- sum(values(surp), na.rm=T)
  summary_dat$Surplus_area[summary_dat$Forest == "Shrub WUI"] <- ((numcells * prod(res(shrub_mask)))/10000) * ha_to_acres
  surp <- terra::mask(surplus, wui_crop, inverse = T)
  numcells <- sum(values(surp), na.rm=T)
  summary_dat$Surplus_area[summary_dat$Forest == "Shrub non-WUI"] <- ((numcells * prod(res(shrub_mask)))/10000) * ha_to_acres
  
  rm(surplus, surp)
  invisible(gc())
  
  deficit <- terra::ifel(all_def < 0, 1, NA)
  defr <- terra::mask(deficit, wui_crop)
  numcells <- sum(values(defr), na.rm=T)
  summary_dat$Deficit_area[summary_dat$Forest == "Shrub WUI"] <- ((numcells * prod(res(shrub_mask)))/10000) * ha_to_acres
  defr <- terra::mask(deficit, wui_crop, inverse = T)
  numcells <- sum(values(defr), na.rm=T)
  summary_dat$Deficit_area[summary_dat$Forest == "Shrub non-WUI"] <- ((numcells * prod(res(shrub_mask)))/10000) * ha_to_acres
  rm(deficit, defr)
  invisible(gc())
  
  #----- Mean and sd of deficit ----------------------------------------------#
  defr <- terra::mask(all_def, wui_crop)
  summary_dat$mean_deficit[summary_dat$Forest == "Shrub WUI"] <- mean(values(defr), na.rm=T)
  summary_dat$sd_deficit  [summary_dat$Forest == "Shrub WUI"] <- sd(values(defr), na.rm=T)
  
  defr <- terra::mask(all_def, wui_crop, inverse=T)
  summary_dat$mean_deficit[summary_dat$Forest == "Shrub non-WUI"] <- mean(values(defr), na.rm=T)
  summary_dat$sd_deficit  [summary_dat$Forest == "Shrub non-WUI"] <- sd(values(defr), na.rm=T)
  
  rm(shrub_mask, vv, all_def, defr)
  invisible(gc())
  #---------------------------------------------------------------------------#
  
  
  #---------------------------------------------------------------------------#
  # Plots
  #---------------------------------------------------------------------------#
  #fri_plot + veg_map_plot + 
  #  forest_types_plot + fire_def_plot +
  #  grassplot + shrubplot +# patchwork::plot_layout(nrow = 3) +
  #  patchwork::plot_annotation(title = "AZ-Coconino County")
  region_name <- gsub("/", "-", region_name, fixed=T)
  ggsave(paste0("figs/", region_name, "1.png"), plot= print(fri_plot + veg_map_plot), 
         width = 8, units="in")
  ggsave(paste0("figs/", region_name, "2.png"), plot= print(forest_types_plot + fire_def_plot), 
         width = 8, units="in")
  ggsave(paste0("figs/", region_name, "3.png"), plot= print(grassplot + shrubplot), 
         width = 8, units="in")
  
  
  summary_dat$Region <- region_name
  
  return(summary_dat)
}
```

```{r spark-regions}
#| eval: false

all_sparks <- unique(spark$SPARK)
all_sparks <- all_sparks[-grep("AK -", all_sparks)]
all_sparks <- all_sparks[-grep("BC -", all_sparks)]

summary_table_dat <- NULL

for (spark_name in all_sparks) {
  
  one_spark <- spark[spark$SPARK == spark_name]
  summary_dat <- do_a_region(spark_name, one_spark)
  summary_table_dat <- rbind(summary_table_dat, summary_dat) 
}

write.csv(summary_table_dat, "SPARK stats.csv", row.names=F)
rm(spark, all_sparks)
```

```{r make-spark-summary-plot}
#| eval: false

summary_dat <- read.csv("SPARK stats.csv")

#----- Take out WUI ----------------------------------------------------------#
x <- grep("WUI", summary_dat$Forest)
summary_dat <- summary_dat[-x,]

#----- A nice graph showing all the regions ----------------------------------#
summary_dat$def_lower <- summary_dat$mean_deficit - summary_dat$sd_deficit
summary_dat$def_upper <- summary_dat$mean_deficit + summary_dat$sd_deficit

# Make short display names for SPARKs
summary_dat$SPARK <- NA
x <- which(summary_dat$Region == "AZ - Coconino County-Flagstaff Region")
summary_dat$SPARK[x] <- "AZ Flagstaff"
x <- which(summary_dat$Region == "CA - Santa Barbara County")
summary_dat$SPARK[x] <- "CA Sta. Barbara"
x <- which(summary_dat$Region == "CA - Tahoe Sierra SPARK")
summary_dat$SPARK[x] <- "CA Tahoe"
x <- which(summary_dat$Region == "CO - Gunnison County and Watersheds")
summary_dat$SPARK[x] <- "CO Gunnison Co"
x <- which(summary_dat$Region == "WA - Klickitat County")
summary_dat$SPARK[x] <- "WA Klickitat Co"
x <- which(summary_dat$Region == "WY - Upper Colorado Basin, Green River")
summary_dat$SPARK[x] <- "WY Colorado/Green"

#----- A plot with no restriction on Y axis ----------------------------------#
suppressMessages(region_plot <- 
  ggplot(summary_dat, aes(x = SPARK, y = mean_deficit, color = Forest)) +
  geom_point(position = position_dodge(width = 0.5), size = 3) +
  geom_linerange(
    aes(ymin = def_lower, ymax = def_upper),
    position = position_dodge(width = 0.5)#,
    #width = 0.2
  ) +
  geom_hline(yintercept = 0) +
  labs(
    title = "Mean deficit by SPARK (negative values = deficit)",
    x = "",
    y = "Fire deficit (bars show sd)",
    color = NULL
    #caption = "Two shrubs omitted for readability"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom"))
ggsave("figs/spark_summary_unzoomed.png", region_plot, width=8.25)

#----- A plot zoomed in, to show more central points -------------------------#
xmin = -10
xmax = 60
summary_dat$def_lower2 <- pmax(summary_dat$def_lower, xmin)
summary_dat$def_upper2 <- pmin(summary_dat$def_upper, xmax)
suppressMessages(region_plot <- 
  ggplot(summary_dat, aes(x = SPARK, y = mean_deficit, color = Forest)) +
  geom_point(position = position_dodge(width = 0.5), size = 3) +
  geom_linerange(
    aes(ymin = def_lower2, ymax = def_upper2),
    position = position_dodge(width = 0.5)#,
    #width = 0.2
  ) +
  geom_hline(yintercept = 0) +
  ylim(c(xmin, xmax)) +
  labs(
    title = "Mean deficit by SPARK (negative values = deficit)",
    x = "",
    y = "Fire deficit (bars show sd)",
    color = NULL,
    caption = "Zoomed in for readability, some points omitted"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom"))
ggsave("figs/spark_summary.png", region_plot, width=8.25)
```

![](figs/spark_summary_unzoomed.png)
![](figs/spark_summary.png)

```{r}
summary_dat <- read.csv("SPARK stats.csv")
#----- Prep and display table ------------------------------------------------#

summary_dat$meansd <- paste(round(summary_dat$mean_deficit, 2), "$\\pm$", 
                            round(summary_dat$sd_deficit, 2))
summary_dat$mean_deficit <- NULL
summary_dat$sd_deficit <- NULL

summary_dat$Total_area <- prettyNum(round(summary_dat$Total_area, 0), 
                                    big.mark = ",")

summary_dat$Surplus_area <- prettyNum(round(summary_dat$Surplus_area, 0), 
                                      big.mark = ",")

summary_dat$Deficit_area <- prettyNum(round(summary_dat$Deficit_area, 0), 
                                      big.mark = ",")



# Can't do this pretty table automagically for a Word doc
#header_indexer <- rep(5, length(unique(summary_dat$SPARK)))
#names(header_indexer) <- unique(summary_dat$SPARK)

#summary_dat$SPARK <- NULL
#kable(summary_dat, booktabs = TRUE,
#      col.names = c("Vegetation type", "Total area (ac)",
#                "Area in surplus", "Area in deficit",
#                "Mean deficit"), 
#  digits = 1) %>% 
#  pack_rows(index = header_indexer)

print(knitr::kable(summary_dat, col.names = c("Vegetation type", "Total area (ac)",
                                              "Area in surplus", "Area in deficit",
                                              "SPARK", "Mean deficit"), digits = 1))
#}

```



## WA - Klickitat County

![](figs/WA - Klickitat County1.png)

![](figs/WA - Klickitat County2.png)

![](figs/WA - Klickitat County3.png)
## CA - Santa Barbara County

![](figs/CA - Santa Barbara County1.png)
![](figs/CA - Santa Barbara County2.png)

![](figs/CA - Santa Barbara County3.png)

## CO - Gunnison County and Watersheds

![](figs/CO - Gunnison County and Watersheds1.png)
![](figs/CO - Gunnison County and Watersheds2.png)

![](figs/CO - Gunnison County and Watersheds3.png)

## WY - Upper Colorado Basin, Green River

![](figs/WY - Upper Colorado Basin, Green River1.png)

![](figs/WY - Upper Colorado Basin, Green River2.png)

![](figs/WY - Upper Colorado Basin, Green River3.png)

## AZ - Coconino County/Flagstaff Region

![](figs/AZ - Coconino County-Flagstaff Region1.png)

![](figs/AZ - Coconino County-Flagstaff Region2.png)

![](figs/AZ - Coconino County-Flagstaff Region3.png)

# States

```{r state-regions}
#| eval: false

all_states <- unique(states$NAME)

# Remove state slivers
all_states <- all_states[which(!all_states %in% c("North Dakota", "Texas",
                                                  "Kansas", "Oklahoma",
                                                  "South Dakota", "Nebraska"))]

summary_table_dat <- NULL

for (state_name in all_states) {
  
  one_state <- states[states$NAME == state_name]
  summary_dat <- do_a_region(state_name, one_state)
  summary_table_dat <- rbind(summary_table_dat, summary_dat) 
}

write.csv(summary_table_dat, "State stats.csv", row.names=F)
```

```{r make-state-summary-plot}
#| eval: false

summary_dat <- read.csv("State stats.csv")
#----- Take out WUI ----------------------------------------------------------#
x <- grep("WUI", summary_dat$Forest)
summary_dat <- summary_dat[-x,]

#----- A nice graph showing all the regions ----------------------------------#
summary_dat$def_lower <- summary_dat$mean_deficit - summary_dat$sd_deficit
summary_dat$def_upper <- summary_dat$mean_deficit + summary_dat$sd_deficit

# Make short display names
state_names <- c("Arizona" = "AZ", "California" = "CA", "Colorado" = "CO",
                 "Idaho" = "ID", "Montana" = "MT", "New Mexico" = "NM", 
                 "Nevada" = "NV", "Oregon" = "OR", "Utah" = "UT", 
                 "Washington" = "WA", "Wyoming" = "WY")
summary_dat$State <- NA
ind <- match(summary_dat$Region, names(state_names))
summary_dat$State <- state_names[ind]

suppressMessages(region_plot <- 
  ggplot(summary_dat, aes(x = State, y = mean_deficit, color = Forest)) +
  geom_point(position = position_dodge(width = 0.5), size = 3) +
  geom_errorbar(
    aes(ymin = def_lower, ymax = def_upper),
    position = position_dodge(width = 0.5),
    width = 0.2
  ) +
  geom_hline(yintercept = 0) +
  ylim(c(-15, 28)) +
  labs(
    title = "Mean deficit by state (negative values = deficit)",
    x = "",
    y = "Fire deficit (bars show sd)",
    color = NULL,
    caption = "Some outliers omitted for readability"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom"))
ggsave("figs/state_summary.png", region_plot, width=8.25)
```

![](figs/state_summary.png)

```{r}

summary_dat <- read.csv("State stats.csv")

#----- Prep and display table ------------------------------------------------#

summary_dat$meansd <- paste(round(summary_dat$mean_deficit, 2), "$\\pm$", 
                            round(summary_dat$sd_deficit, 2))
summary_dat$mean_deficit <- NULL
summary_dat$sd_deficit <- NULL

summary_dat$Total_area <- prettyNum(round(summary_dat$Total_area, 0), 
                                    big.mark = ",")

summary_dat$Surplus_area <- prettyNum(round(summary_dat$Surplus_area, 0), 
                                      big.mark = ",")

summary_dat$Deficit_area <- prettyNum(round(summary_dat$Deficit_area, 0), 
                                      big.mark = ",")

# Can't do this pretty table automagically for a Word doc
#header_indexer <- rep(5, length(unique(summary_dat$SPARK)))
#names(header_indexer) <- unique(summary_dat$SPARK)

#summary_dat$SPARK <- NULL
#kable(summary_dat, booktabs = TRUE,
#      col.names = c("Vegetation type", "Total area (ac)",
#                "Area in surplus", "Area in deficit",
#                "Mean deficit"), 
#  digits = 1) %>% 
#  pack_rows(index = header_indexer)

print(knitr::kable(summary_dat, col.names = c("Vegetation type", "Total area (ac)",
                                              "Area in surplus", "Area in deficit",
                                              "State", "Mean deficit"), digits = 1))
#}

```

## Arizona

![](figs/Arizona1.png)

![](figs/Arizona2.png)

![](figs/Arizona3.png)



## California

![](figs/California1.png)

![](figs/California2.png)

![](figs/California3.png)

## Colorado

![](figs/Colorado1.png)

![](figs/Colorado2.png)

![](figs/Colorado3.png)

## Idaho

![](figs/Idaho1.png)

![](figs/Idaho2.png)

![](figs/Idaho3.png)


## Montana

![](figs/Montana1.png)

![](figs/Montana2.png)

![](figs/Montana3.png)

## New Mexico

![](figs/New Mexico1.png)

![](figs/New Mexico2.png)

![](figs/New Mexico3.png)


## Nevada

![](figs/Nevada1.png)

![](figs/Nevada2.png)

![](figs/Nevada3.png)


## Oregon

![](figs/Oregon1.png)

![](figs/Oregon2.png)

![](figs/Oregon3.png)


## Utah

![](figs/Utah1.png)

![](figs/Utah2.png)

![](figs/Utah3.png)

## Washington

![](figs/Washington1.png)

![](figs/Washington2.png)

![](figs/Washington3.png)

## Wyoming

![](figs/Wyoming1.png)

![](figs/Wyoming2.png)

![](figs/Wyoming3.png)

# Wildland-Urban Interface

WUI data was downloaded from [https://silvis.forest.wisc.edu/maps-data/wildland-urban-interface/]( https://silvis.forest.wisc.edu/maps-data/wildland-urban-interface/). 

There are several possible ways to define the WUI. I am using the product derived from building footprints, at the finest available resolution (100 m).


```{r rasterize-wui}
#| eval: false

#----- Rasterize the WUI -----------------------------------------------------#
fri <- terra::rast("../temp_rasters/all_fri_vals.tif")

#----- Load WUI --------------------------------------------------------------#
wui <- terra::vect("Z:/project_data/western_fire/wui/CONUS_WUI_structures_MSBFP.gdb", layer="CONUS_wui_poly_final_100")
wui <- terra::project(wui, fri)
wui <- terra::crop(wui, fri)

rast <- terra::rast(fri)

wui_rast <- rasterize(wui, rast, fun="count", background = NA)
writeRaster(wui_rast, "../temp_rasters/wui.tif")
```

# Recent burns - not deliberate

In order to calculate fire deficit / surplus, we need the the best possible record of recent fires. We are using the WUMI dataset created by Park Williams and compiled by Tyler McIntosh. This dataset can be downloaded from the WFFRC Cyverse folder.

We use this dataset by turning it into a raster of times each pixel has burned. I investigated whether the rasterization process could be expected to change the fire area estimate due to the rasterization algorithm, but the 30 m resolution is so much smaller than the size of fire polygons that it should not matter. (I just looked visually. I didn't prove this with math, but I could.)

**Output:** raster "num_fires.tif"


```{r create-fire-count-raster}
#| eval: false

#-----------------------------------------------------------------------------#
# This creates a raster where each cell is a count of the number of fire 
# polygons that intersect it.
#-----------------------------------------------------------------------------#

#----- Fire perimeters from Tyler --------------------------------------------#
wumi_gpkg <- geopackage("Z:/project_data/western_fire/WUMI/WUMI_20250509_main_fires_unified/WUMI_20250509_main_fires_unified.gpkg")
fire_perimeters <- gpkg_vect(wumi_gpkg, "WUMI_20250509_main_fires_unified") 

#----- Fire return interval --------------------------------------------------#
fri <- terra::rast("../west_us_FRI.tif")

fire_perimeters <- terra::project(fire_perimeters, fri)

#----- Create an output raster -----------------------------------------------#
num_burns <- terra::rast(fri)

# rasterize using function to count overlapping polygons
r_count <- rasterize(fire_perimeters, num_burns, fun="count", background = 0)
writeRaster(r_count, "../temp_rasters/num_fires.tif")
```

# Prescribed burns

This dataset was created by Tyler McIntosh, who notes:

> This dataset is derived from the [https://reshapewildfire.org/resources/twig-data-resources](ReShape TWIG dataset), which is essentially a more comprehensive version of the NFPORS + FACTS integration that I performed. It was just recently released by SWERI.

> The derived dataset linked above contains polygon information on intentional ignitions across the western US states. I've filtered it to only include those that were actually completed, I have removed duplicated events, and filtered to those which either marked as intentional ignitions in the TWIG classification OR which are listed as type "Hand Pile Burn", "Machine Pile Burn", "Broadcast Burn", or "Jackpot Burn". All polygon geometries have been validated.

> There is one caveat to this dataset, the fix for which was running when my laptop gave up on life. There are some cases where there are multiple polygons for the same treatment event, but which overlap. An example of this would be hand pile burning near park service structures to create defensible space, in which they appear to have created a buffered polygon around points on each structure. Whenever structures are grouped closely, you end up with many polygons that overlap. If areas from the polygons are pulled naively, it inflates the area treated. The solution is to merge the polygons that occurred on the same date and with the same treatment IDs across the entire dataset, but this has NOT been applied to this version of the gpkg. So just be aware that it is possible to have multiple overlapping polygons in a single year at a single location.

> I think that this dataset is quite defensible as 'best-easily-available' for your current use. If Winslow wanted an 'absolutely best possible' version at some point in the future there are some additional datasets that could be brought in, but that would require more cross-validation, checking for duplicates, and confirming classification matches across treatment types. If we wanted to go that route in the future I think we would want to loop in Kristin Brazunias up at UW, as she has been working on a workflow to integrate these additional treatment datasets (but at a local scale) for another project I'm semi-involved with.

So I will do the polygon merge mentioned, and rasterize the dataset to create a number of prescribed burns per pixel raster. The total merged area in the west is 9,429 ha less than the unmerged; which is the amount we would have overestimated.

```{r prescribed-burns-processing}
#| eval: FALSE

fri <- terra::rast("../temp_rasters/all_fri_vals.tif")

#----- Load prescribed burns, crop, project ----------------------------------#
rx <- terra::vect("Z:/project_data/western_fire/prescribed burns/twig_planned_ignition_no_dup_west.gpkg")
rx <- terra::project(rx, fri)
rx <- terra::crop(rx, fri)

# Tyler's suggested method:
# I was using 'name', and the following steps:
# - turn empty 'name' strings into NAs
# - filter to only polygons with all of name, actual_completion_date, and type
# - merge polygons that have matching 'name', 'type', AND 
#   'actual_completion_date' AND are spatially overlapping one another (not 
#    just next to each other). Could also require the same activity, method, 
#    and/or equipment if desired
# - bind the new merged polygons back to the others

# Since I am rasterizing, I will just make a single burn ID and then 
# dissolve any polygons with the same burn ID, not really caring if they touch.
# Once they are a raster, it doesn't matter if they were a multipart polygon.

#----- Turn empty 'name' strings into NAs ------------------------------------#
rx$name <- ifelse(rx$name %in% c("", " "), NA, rx$name)

#---- Turn NAs back into a count - so they don't look like the same thing ----#
burn_names <- rx$name
burn_names <- ifelse(is.na(burn_names), 1:length(burn_names), burn_names)

#----- Combine name, date, and type to make a unique burn ID -----------------#
# A lot of type codes are missing, not going to worry about that too much.
rx$unique_burn_id <- as.factor(paste(burn_names, 
                           rx$actual_completion_date, 
                           rx$activity_code, sep="-"))

#----- Dissolve polygons with the same burn ID. If they arne't overlapping, --#
# this shouldn't change anything
rx2 <- terra::aggregate(rx, by="unique_burn_id")

# For a quick area check - we reduce by 9,420.5 ha
#areas <- expanse(rx, unit="m")
#areas2 <- expanse(rx2, unit='m')

rast <- terra::rast(fri)

rx_rast <- rasterize(rx2, rast, fun="count", background = NA)
writeRaster(rx_rast, "../temp_rasters/num_rx.tif")
```


# Landfire historical fire regime / fire return interval

Fire return interval data is from [Landfire](https://landfire.gov/fire-regime/fri). Let's check the completeness of the raster - looks pretty complete.

```{r crop-fri-rast-to-western-us}
#| eval: FALSE

#----- Load the BPS raster ---------------------------------------------------#
fri <- terra::rast("Z:/project_data/landfire data/Fire return interval/LF2016_FRI_200_CONUS/Tif/LC16_FRI_200.tif")
fri_crs <- crs(fri)

#-----------------------------------------------------------------------------#
# A long and painful journey to prepare the study domain raster so that I can
# successfully crop and mask to it. 
#-----------------------------------------------------------------------------#
study_domain <- terra::rast("Z:/project_data/western_fire/for_Lora/study_domain.tif")

#----- terra::project to the FRI raster. This will mess up the study domain --#
# extent. But if I don't do this...can't mask later, cells won't match.
study_domain <- terra::project(study_domain, fri)

#----- Now shrink the study domain back down to reasonable size
# Set 0s to NA
study_domain <- terra::classify(study_domain, cbind(0, NA))
# Trim off surrounding NA to re-set the extent
study_domain <- trim(study_domain)
writeRaster(study_domain, "../temp_rasters/study_domain.tif")

#----- Crop and mask to study domain -----------------------------------------#
fri_crop <- terra::crop(fri, study_domain)
fri_crop <- terra::mask(fri_crop, study_domain)

rm(fri, study_domain)
gc()

#----- Save our work here ----------------------------------------------------#
writeRaster(fri_crop, "../temp_rasters/fri_crop.tif")
rm(fri_crop)
gc()
```

```{r make-all-fri-rast}
#| eval: false
fri <- terra::rast("../temp_rasters/fri_crop.tif")

#----- Get the CSV data that has fire return interval for all BPS codes ------#
bps <- read.csv("Z:/project_data/landfire data/fire return interval/LF2016_FRI_200_CONUS/CSV_Data/LF16_FRI_200.csv")

#----- NA out unavailable FRIs -----------------------------------------------#
good_bps <- which(bps$FRI_ALLFIR > 0) 

#----- Replace BPS code with FRI, making NAs for bad FRIs --------------------#
# This matrix will be used to create a FRI raster out of the BPS codes 
# currently stored in the raster
mat <- matrix(c(bps$Value[good_bps], bps$FRI_ALLFIR[good_bps]), 
              nrow=length(good_bps), ncol=2)

tile <- terra::classify(fri, mat, others=NA)
writeRaster(tile, "../temp_rasters/all_fri_vals.tif", overwrite = TRUE)
```

```{r}
fri <- terra::rast("../temp_rasters/all_fri_vals.tif")
# This used to use the tigris package, but one day the data wasn't available on
# line and the code broke. So I downloaded a shapefile instead
#states <- states(cb=TRUE)
states <- terra::vect("../Data/s_05mr24.shp")
states <- terra::project(states, fri)
states <- terra::crop(states, fri)
plot(fri, axes=F, 
     range=c(0,500),
     fill_range=T,
     #col=map.pal("bgyr", bias=3),
     main="LANDFIRE Fire return interval")
plot(states, add=T, fill=NULL)
```

## Alaska

No locations in Alaska have a FRI $\leq$ 40 years. No further products will be created for Alaska at this time.

**Output:** none.

## Western US map of Fire Return Interval

**Output:** raster called "west_us_FRI.tif", of CONUS cropped to the WFFRC study area, with a map of Landfire's 2016 FRI_ALLFIR values where FRI_ALLFIR is $\leq$ 40. (See appendix for summary Landfire documentation.)

```{r create-western-us-fri-rast}
#| eval: FALSE

#-----------------------------------------------------------------------------#
# Note that this uses a tiled approach, because I had a lot of crashes trying
# to get this to work. An updated version of terra worked much better and no
# longer requires tiles. I am leaving this in as a legacy, in case it is useful
# later; but you can go straight to the classify step if desired.
#-----------------------------------------------------------------------------#


#----- Get the CSV data that has fire return interval for all BPS codes ------#
bps <- read.csv("Z:/project_data/landfire data/fire return interval/LF2016_FRI_200_CONUS/CSV_Data/LF16_FRI_200.csv")

#----- Filter out those units with an all-fire FRI <= 40 years ---------------#
good_bps <- which(bps$FRI_ALLFIR > 0 & bps$FRI_ALLFIR <= 40) 

#----- Replace BPS code with FRI, making NAs for bad FRIs --------------------#
# This matrix will be used to create a FRI raster out of the BPS codes 
# currently stored in the raster
mat <- matrix(c(bps$Value[good_bps], bps$FRI_ALLFIR[good_bps]), 
              nrow=length(good_bps), ncol=2)

#-----------------------------------------------------------------------------#
# This raster is enormous and unwieldy and regularly crashes R just for fun,
# even on the big machines. We're going to split it up into tiles.
#-----------------------------------------------------------------------------#
#----- Make a directory to put the files into --------------------------------#
if (!dir.exists("../tempproc")) dir.create("../tempproc")

#----- Divide the raster into tiles for processing ---------------------------#
fri_crop <- terra::rast("../temp_rasters/fri_crop.tif")
tile_size <- c(10000, 10000)  # Size of each tile (rows, columns)
tiles <- makeTiles(fri_crop, tile_size, filename = "tempproc/tile.tif", 
                   overwrite = TRUE)
rm(fri_crop)
gc()

#----- Replace the BPS codes with FRI, dropping the smalls -------------------#
# If previous step is already done...
#tiles <- list.files("tempproc")
#tiles <- paste0("tempproc/", tiles[-grep("aux", tiles)])
processed_tiles <- lapply(tiles, function(tile_path) {
  tile <- terra::rast(tile_path)
  tile <- terra::classify(tile, mat, others=NA)
  output_path <- gsub("\\.tif$", "_processed.tif", tile_path)
  writeRaster(tile, output_path, overwrite = TRUE)
  return(output_path)
})
gc()


#----- Mosaic the processed tiles back together ------------------------------#
processed_tiles <- paste0("../tempproc/",
                          list.files("../tempproc", pattern="processed"))
processed_rasters <- lapply(processed_tiles, terra::rast)
mosaic <- do.call(terra::mosaic, processed_rasters)

writeRaster(mosaic, "../west_us_FRI.tif", overwrite = TRUE)
```

```{r create-alaska-fri-rast}
#| eval: FALSE
#----- Alaska ----------------------------------------------------------------#

#----- Get the CSV data that has fire return interval for all BPS codes ------#
ak_bps <- read.csv("Z:/project_data/landfire data/fire return interval/LF2023_FRI_240_AK/CSV_Data/LF23_FRI_240.csv")

#----- Filter out those units with an all-fire FRI <= 40 years ---------------#
#bps <- bps[bps$FRI_ALLFIR <= 40 & bps$FRI_ALLFIR > 0,]
bad_bps <- which(ak_bps$FRI_ALLFIR > 40 | ak_bps$FRI_ALLFIR < 0)

akfri <- terra::rast("Z:/project_data/landfire data/fire return intervan/LF2023_FRI_240_AK/Tif/LA23_FRI_240.tif")
```

```{r}
#| results: false
#| message: false

fri <- terra::rast("../west_us_FRI.tif")

# This used to use the tigris package, but one day the data wasn't available on
# line and the code broke. So I downloaded a shapefile instead
#states <- states(cb=TRUE)
states <- terra::vect("../Data/s_05mr24.shp")
states <- terra::project(states, fri)
states <- terra::crop(states, fri)
plot(fri, axes=F,
     main="Fire return interval where values <= 40 years")
plot(states, add=T, fill=NULL)
```

\newpage

# Fire deficit / surplus for FRI $\leq$ 40 years

**Output:** raster called "western_us_fire_deficit.tif". The value in each raster is the deficit or surplus. Values above zero are surplus, and represent the number of times more an area has burned than it should have (i.e. a value of 2 means the area has burned twice as many times as expected). Values below zero are deficit, and are interpretable in the same way (-2 means the area should have burned twice as much as it did).

The number of expected fires $N_{exp}$ in the 40 years of our burn data is $40/FRI$, and call $N_{act}$ the number of observed fires from the dataset (wild plus prescribed burns). For surpluses, we take $N_{act}/N_{exp}$; for deficits, we take the inverse of that, and add a negative. (If an area has not burned ($N_{act}=0$), deficit will be equal to negative expected fires.)

For comparison, there is a separate raster called "western_us_fire_deficit_norx.tif" that does not contain prescribed burns.

```{r create-fire-deficit-raster}
#| eval: false

#----- Actual number of fires - wild plus prescribed -------------------------#
n_act <- terra::rast("../temp_rasters/num_fires.tif") +
         terra::rast("../temp_rasters/num_rx.tif")

#----- Expected number of fires ----------------------------------------------#
fri <- terra::rast("../west_us_FRI.tif")
n_exp <- 40/fri

def <- ifel(n_act > n_exp, n_act/n_exp, (-1 * n_exp/n_act))
def <- ifel(n_act == 0 & n_exp > 0, -1 * n_exp, def)
writeRaster(def, "../western_us_fire_deficit.tif", overwrite=T)
```

```{r}
def <- terra::rast("../western_us_fire_deficit.tif")

# This doesn't work - error: long terra::vectors not supported yet
#library(tidyterra)
#ggplot(def) + 
#  geom_spatraster(aes(fill=value)) +
#  ggtitle("Fire deficit / surplus") +
#  scale_fill_gradient2(low="red", mid="green", high="blue", 
#                       midpoint=1)

# Bias tweaks the scale. The higher the number, the more colors are stuffed
# into the lower end of the scale.
plot(def, axes=F,
     range=c(-5,5),
     fill_range=T,
     col=map.pal("bgyr"),#, bias=2.5),
     main="Fire deficit / surplus")
plot(states, add=T, fill=NULL)
rm(def)
invisible(gc())
```

\newpage

# Forest Area

**Output:** raster called "western_us_forest.tif"

A value of 1 indicates forest according to our definition, NA for all others. Our definition of forest is a pixel that is one of the following cover classes in the [Landfire EVC](https://landfire.gov/vegetation/evc):

-   Developed-upland deciduous forest
-   Developed-upland evergreen forest
-   Developed-upland mixed forest
-   Tree cover - 20% to 100%

Note: we originally tried tree cover at 50-100%, but 20% was a closer approximation to the LCMS definition of forest, and helped sort out some mixed cover classes.

We originally used a definition of forest that was the intersection between Landfire and LCMS, but it turns out that LCMS does not do a good job of correctly differentiating between shrubs and trees, which is crucial for many of our areas. The exercise did help validate the Landfire cover classes.

(For a complete list of the cover classes, see the appendix.)

```{r crop-evc-rast-to-western-us}
#| eval: FALSE

#----- Load the BPS raster ---------------------------------------------------#
evc <- terra::rast("Z:/project_data/landfire data/vegetation/existing vegetation cover/LF2016_EVC_200_CONUS/Tif/LC16_EVC_200.tif")
study_domain <- terra::rast("../temp_rasters/study_domain.tif")

#----- Crop and mask study domain --------------------------------------------#
evc_crop <- terra::crop(evc, study_domain)
evc_crop <- terra::mask(evc_crop, study_domain)

rm(evc)
gc()

#----- Save our work here ----------------------------------------------------#
writeRaster(evc_crop, "../temp_rasters/evc_crop.tif")
rm(evc_crop)
gc()
```

```{r create-evc-western-us-forest-rast}
#| eval: FALSE
#----- Get the CSV data with vegetation codes --------------------------------#
evc_codes <- read.csv("Z:/project_data/landfire data/vegetation/existing vegetation cover/LF2016_EVC_200_CONUS/CSV_Data/LF16_EVC_200.csv")

#-----------------------------------------------------------------------------#
# Make a forest cover mask for EVC
#-----------------------------------------------------------------------------#
#----- Upland forest cover classes
good_codes <- grep("Forest", evc_codes$CLASSNAMES)

#----- Forest cover - conditional inclusion. Mark with a 1 -------------------#
good_codes <- c(good_codes, grep("Tree Cover = 2.*", evc_codes$CLASSNAMES))
good_codes <- c(good_codes, grep("Tree Cover = 3.*", evc_codes$CLASSNAMES))
good_codes <- c(good_codes, grep("Tree Cover = 4.*", evc_codes$CLASSNAMES))
good_codes <- c(good_codes, grep("Tree Cover = 5.*", evc_codes$CLASSNAMES))
good_codes <- c(good_codes, grep("Tree Cover = 6.*", evc_codes$CLASSNAMES))
good_codes <- c(good_codes, grep("Tree Cover = 7.*", evc_codes$CLASSNAMES))
good_codes <- c(good_codes, grep("Tree Cover = 8.*", evc_codes$CLASSNAMES))
good_codes <- c(good_codes, grep("Tree Cover = 9.*", evc_codes$CLASSNAMES))
good_codes <- c(good_codes, grep("Tree Cover >= 99.*", evc_codes$CLASSNAMES))

mat <- matrix(c(evc_codes$VALUE[good_codes], rep(1, length(good_codes))), 
              nrow=length(good_codes), ncol=2)

evc_crop <- terra::rast("../temp_rasters/evc_crop.tif")
evc <- terra::classify(evc_crop, mat, others=NA)
rm(evc_crop)
gc()
writeRaster(evc, "../western_us_forest.tif", overwrite = TRUE)
```

```{r}
forest <- terra::rast("../western_us_forest.tif")
plot(forest, axes=F, main="Western US forest cover", col="darkgreen", legend = F)
plot(states, add=T, fill=NULL)
rm(forest)
invisible(gc())
```

## Subdivide forest by fire regime

Our identified forest regions can be subdivided by fire regime as follows:

**Output:** raster called "western_us_frg_forest.tif" with the following values:

-   1: dry frequent fire forest (FRG groups I-A, I-B, and I-C))
-   2: mixed severity fire forest (FRG groups IIIA and IIIB)
-   3: long interval stand replacing fire forest (FRG groups IV-A and IV-B)
-   4: long interval stand replacing fire forest (FRG groups V-A, and V-B)

(See appendix for a complete list of FRG codes.)

```{r crop-frg-rast-to-western-us}
#| eval: FALSE

#----- Load the BPS raster ---------------------------------------------------#
frg <- terra::rast("Z:/project_data/landfire data/fire regime/LF2016_FRG_200_CONUS/Tif/LC16_FRG_200.tif")
study_domain <- terra::rast("../temp_rasters/study_domain.tif")

#----- Crop and mask to study domain -----------------------------------------#
frg_crop <- terra::crop(frg, study_domain)
frg_crop <- terra::mask(frg_crop, study_domain)

rm(frg, study_domain)
gc()

#----- Save our work here ---------------------------------------------------#
writeRaster(frg_crop, "../temp_rasters/frg_crop.tif", overwrite=T)
rm(frg_crop)
gc()
```

```{r create-western-us-frg-rast}
#| eval: FALSE

#-----------------------------------------------------------------------------#
# I am going to make a raster that has FRG codes. 
# 1 = FRG groups I-A, I-B, and I-c
# 2 = FRG groups IIIA and IIIB
# 3 = FRG groups IV-A and IV-B
# 4 = FRG groups IV-A, IV-B, V-A, and V-B
#-----------------------------------------------------------------------------#

#----- Get the CSV data that has fire return interval for all BPS codes ------#
bps <- read.csv("Z:/project_data/landfire data/fire regime/LF2016_FRG_200_CONUS/CSV_Data/LF16_FRG_200.csv")

frg_groups <- data.frame(frg = c("I-A", "I-B", "I-C", "III-A", "III-B",
                                 "IV-A", "IV-B", "V-A", "V-B"),
                         grp = c(1,1,1,2,2,3,3,4,4))

#----- Filter out to units in one of our groupings ---------------------------#
good_bps <- which(bps$FRG_NEW %in% frg_groups$frg) 
bps <- bps[good_bps,]
bps$grp <- frg_groups$grp[match(bps$FRG_NEW, frg_groups$frg)]

#----- Replace BPS code with my FRG code, making NAs for all others ----------#
mat <- matrix(c(bps$Value, bps$grp), nrow=nrow(bps), ncol=2)

frg_crop <- terra::rast("../temp_rasters/frg_crop.tif")
frg <- terra::classify(frg_crop, mat, others=NA)
writeRaster(frg, "../temp_rasters/frg.tif", overwrite=T)
```

```{r create-classified-forest-rasts}
#| eval: false

#----- Load my FRG groups, and the forest raster -----------------------------#
frg <- terra::rast("../temp_rasters/frg.tif")
forest <- terra::rast("../western_us_forest.tif")

#----- Dry frequent fire forest - group 1 ------------------------------------#
dff <- sum(frg, forest)
dff <- dff - 1
levels(dff) <- data.frame(ID = 1:4, 
                          category = c("Dry frequent fire", "Mixed severity fire", 
                                       "Stand replacing group IV", "Stand replacing group V"))
writeRaster(dff, "../western_us_frg_forest.tif", overwrite=T)
```

```{r}
dff <- terra::rast("../western_us_frg_forest.tif")

plot(dff, main="Forest area categorized by fire regime",
     axes=F)
plot(states, add=T, fill=NULL)
rm(dff)
invisible(gc())
```

## Forest area fire deficit/surplus where FRI $\leq$ 40 years

**Output:** raster called "forest_deficit.tif", where the values in the raster "western_us_fire_deficit.tif" are masked out to areas in our forest raster ("western_us_forest.tif").

```{r create-forest-deficit-rast}
#| eval: false

defi <- terra::rast("../western_us_fire_deficit.tif")
fors <- terra::rast("../western_us_forest.tif")

fordef <- terra::mask(defi, fors)
writeRaster(fordef, "../forest_deficit.tif", overwrite=T)
```

```{r}
fordef <- terra::rast("../forest_deficit.tif")
plot(fordef, axes=F,
     range=c(-5,5),
     fill_range=T,
     #col=map.pal("bgyr", bias=2.5),
     main="Forest area fire deficit / surplus")
plot(states, add=T, fill=NULL)
rm(fordef)
invisible(gc())
```

\newpage

# Grassland Area

**Output:** raster called "west_us_grass.tif"

A value of 1 indicates grassland according to our definition, NA for all others. Our definition of grassland is a pixel that is one of the following cover classes in [Landfire EVC](https://landfire.gov/vegetation/evc) 2016:

-   Developed-Upland Herbaceous
-   Developed - Open Space
-   Herb cover 20-90%

There are herb cover classes \< 20%, but this appears to indicate a pixel that is mostly barren.

```{r create-evc-grass-rast}
#| eval: FALSE
#----- Get the CSV data with vegetation codes --------------------------------#
evc_codes <- read.csv("Z:/project_data/landfire data/vegetation/existing vegetation cover/LF2016_EVC_200_CONUS/CSV_Data/LF16_EVC_200.csv")

#----- Filter cover to grass cover types -------------------------------------#
good_codes <- which(evc_codes$VALUE %in% c(
  16, # Developed-Upland Herbaceous
  21 # Developed - Open Space
  #63, # NASS-Row Crop-Close Grown Crop
  #64, # NASS-Row Crop
  #65, # NASS-Close Grown Crop
  #68, # NASS-Wheat
  #82  # Cultivated Crops
))
good_codes <- c(good_codes, grep("Herb Cover = 2.*", evc_codes$CLASSNAMES))
good_codes <- c(good_codes, grep("Herb Cover = 3.*", evc_codes$CLASSNAMES))
good_codes <- c(good_codes, grep("Herb Cover = 4.*", evc_codes$CLASSNAMES))
good_codes <- c(good_codes, grep("Herb Cover = 5.*", evc_codes$CLASSNAMES))
good_codes <- c(good_codes, grep("Herb Cover = 6.*", evc_codes$CLASSNAMES))
good_codes <- c(good_codes, grep("Herb Cover = 7.*", evc_codes$CLASSNAMES))
good_codes <- c(good_codes, grep("Herb Cover = 8.*", evc_codes$CLASSNAMES))
good_codes <- c(good_codes, grep("Herb Cover = 9.*", evc_codes$CLASSNAMES))
good_codes <- c(good_codes, grep("Herb Cover >.*", evc_codes$CLASSNAMES))

#----- Make a grass cover mask - 1 if in cover, 0 if not ---------------------#
mat <- matrix(c(evc_codes$VALUE[good_codes], rep(1, length(good_codes))), 
              nrow=length(good_codes), ncol=2)

evc_crop <- terra::rast("../temp_rasters/evc_crop.tif")
evc <- terra::classify(evc_crop, mat, others=NA)
rm(evc_crop)
gc()
writeRaster(evc, "../western_us_grass.tif", overwrite = TRUE)
```

```{r}
grass <- terra::rast("../western_us_grass.tif")
plot(grass, axes=F, main="Western US grass cover", col="darkgoldenrod3", legend = F)
plot(states, add=T, fill=NULL)
rm(grass)
invisible(gc())
```

## Subdivide grass by fire regime

Our identified forest regions can be subdivided by fire regime as follows:

**Output:** raster called "western_us_frg_grass.tif" with the following values:

-   1: dry frequent fire (FRG groups I-A, I-B, and I-C))
-   2: mixed severity fire (FRG groups IIIA and IIIB)
-   3: long interval stand replacing fire (FRG groups IV-A and IV-B)
-   4: long interval stand replacing fire (FRG groups V-A, and V-B)

(See appendix for a complete list of FRG codes.)

```{r create-classified-grass-rasts}
#| eval: false

#----- Load my FRG groups, and the grass raster ------------------------------#
frg <- terra::rast("../temp_rasters/frg.tif")
grass <- terra::rast("../western_us_grass.tif")

#----- Dry frequent fire - group 1 -------------------------------------------#
dff <- sum(frg, grass)
dff <- dff - 1
levels(dff) <- data.frame(ID = 1:4, 
                          category = c("Dry frequent fire", "Mixed severity fire", 
                                       "Stand replacing group IV", "Stand replacing group V"))
writeRaster(dff, "../western_us_frg_grass.tif", overwrite=T)
```

```{r}
dff <- terra::rast("../western_us_frg_grass.tif")

plot(dff, main="Grassland area categorized by fire regime",
     axes=F)
plot(states, add=T, fill=NULL)
rm(dff)
invisible(gc())
```

## Grass area fire deficit/surplus where FRI $\leq$ 40 years

**Output:** raster called "grass_deficit.tif", where the values in the raster "western_us_fire_deficit.tif" are masked out to areas in our grass raster ("western_us_grass.tif").

```{r create-grass-deficit-rast}
#| eval: false

defi <- terra::rast("../western_us_fire_deficit.tif")
fors <- terra::rast("../western_us_grass.tif")

fordef <- terra::mask(defi, fors)
writeRaster(fordef, "../grass_deficit.tif", overwrite=T)
```

```{r}
fordef <- terra::rast("../grass_deficit.tif")
plot(fordef, axes=F,
     range=c(-5,2),
     fill_range=T,
     #col=map.pal("bgyr", bias=2.5),
     main="Grass area fire deficit / surplus")
plot(states, add=T, fill=NULL)
rm(fordef)
invisible(gc())
```

# Shrub/chaparral Area

**Output:** raster called "west_us_shrub.tif"

A value of 1 indicates shrubland according to our definition, NA for all others. Our definition of shrubland is a pixel that is one of the following [Landfire EVC](https://landfire.gov/vegetation/evc) 2016 cover classes:

-   Developed-Upland Shrubland
-   Shrub cover 20-90% (although actual values only appear up to 79%)

There are shrub cover classes \< 20%, but this appears to indicate a pixel that is mostly barren.

```{r create-evc-shrub-rast}
#| eval: FALSE
#----- Get the CSV data with vegetation codes --------------------------------#
evc_codes <- read.csv("Z:/project_data/landfire data/vegetation/existing vegetation cover/LF2016_EVC_200_CONUS/CSV_Data/LF16_EVC_200.csv")

#----- Filter cover to grass cover types -------------------------------------#
good_codes <- which(evc_codes$VALUE %in% c(
  17 # Developed-Upland Shrubland
))
good_codes <- c(good_codes, grep("Shrub Cover = 2.*", evc_codes$CLASSNAMES))
good_codes <- c(good_codes, grep("Shrub Cover = 3.*", evc_codes$CLASSNAMES))
good_codes <- c(good_codes, grep("Shrub Cover = 4.*", evc_codes$CLASSNAMES))
good_codes <- c(good_codes, grep("Shrub Cover = 5.*", evc_codes$CLASSNAMES))
good_codes <- c(good_codes, grep("Shrub Cover = 6.*", evc_codes$CLASSNAMES))
good_codes <- c(good_codes, grep("Shrub Cover = 7.*", evc_codes$CLASSNAMES))
good_codes <- c(good_codes, grep("Shrub Cover = 8.*", evc_codes$CLASSNAMES))
good_codes <- c(good_codes, grep("Shrub Cover = 9.*", evc_codes$CLASSNAMES))
good_codes <- c(good_codes, grep("Shrub Cover >.*", evc_codes$CLASSNAMES))

#----- Make a shrub cover mask - 1 if in cover, 0 if not ---------------------#
mat <- matrix(c(evc_codes$VALUE[good_codes], rep(1, length(good_codes))), 
              nrow=length(good_codes), ncol=2)

evc_crop <- terra::rast("../temp_rasters/evc_crop.tif")
evc <- terra::classify(evc_crop, mat, others=NA)
rm(evc_crop)
gc()
writeRaster(evc, "../western_us_shrub.tif", overwrite = TRUE)
```

```{r}
shrub <- terra::rast("../western_us_shrub.tif")
plot(shrub, axes=F, main="Western US shrub cover", col="burlywood4", legend = F)
plot(states, add=T, fill=NULL)
rm(shrub)
invisible(gc())
```

## Subdivide shrubland by fire regime

Our identified forest regions can be subdivided by fire regime as follows:

**Output:** raster called "western_us_frg_shrub.tif" with the following values:

-   1: dry frequent fire (FRG groups I-A, I-B, and I-C))
-   2: mixed severity fire (FRG groups IIIA and IIIB)
-   3: long interval stand replacing fire (FRG groups IV-A and IV-B)
-   4: long interval stand replacing fire (FRG groups V-A, and V-B)

(See appendix for a complete list of FRG codes.)

```{r create-classified-shrub-rasts}
#| eval: false

#----- Load my FRG groups, and the shrub raster ------------------------------#
frg <- terra::rast("../temp_rasters/frg.tif")
shrub <- terra::rast("../western_us_shrub.tif")

#----- Dry frequent fire - group 1 -------------------------------------------#
dff <- sum(frg, shrub)
dff <- dff - 1
levels(dff) <- data.frame(ID = 1:4, 
                          category = c("Dry frequent fire", "Mixed severity fire", 
                                       "Stand replacing group IV", "Stand replacing group V"))
writeRaster(dff, "../western_us_frg_shrub.tif", overwrite=T)
```

```{r}
dff <- terra::rast("../western_us_frg_shrub.tif")

plot(dff, main="Shrub area categorized by fire regime",
     axes=F)
plot(states, add=T, fill=NULL)
rm(dff)
invisible(gc())
```

## Shrub area fire deficit/surplus where FRI $\leq$ 40 years

**Output:** raster called "shrub_deficit.tif", where the values in the raster "western_us_fire_deficit.tif" are masked out to areas in our shrub raster ("western_us_shrub.tif").

```{r create-shrub-deficit-rast}
#| eval: false

defi <- terra::rast("../western_us_fire_deficit.tif")
fors <- terra::rast("../western_us_shrub.tif")

fordef <- terra::mask(defi, fors)
writeRaster(fordef, "../shrub_deficit.tif", overwrite=T)
```

```{r}
fordef <- terra::rast("../shrub_deficit.tif")
plot(fordef, axes=F,
     range=c(-5,5),
     fill_range=T,
     #col=map.pal("bgyr", bias=2.5),
     main="Shrub area fire deficit / surplus")
plot(states, add=T, fill=NULL)
rm(fordef)
invisible(gc())
```

```{r make-all-veg-rast}
#| eval: false

#----- For later analysis - make a raster combining all of our vegetation types

forest <- terra::rast("../western_us_forest.tif")
grass  <- terra::rast("../western_us_grass.tif")
shrub  <- terra::rast("../western_us_shrub.tif")

#----- NAs become 0, so we can add -------------------------------------------#
forest <- subst(forest, NA, 0)
grass  <- subst(grass , NA, 0)
shrub  <- subst(shrub , NA, 0)

#----- Make into a categorical raster situation ------------------------------#
grass <- subst(grass, 1, 2)
shrub <- subst(shrub, 1, 3)

all_veg <- forest + grass + shrub
all_veg <- subst(all_veg, 0, NA)

cats <- data.frame(id = 1:3, veg = c("Forest", "Grass", "Shrub"))
levels(all_veg) <- cats

writeRaster(all_veg, "../temp_rasters/combined_veg_area.tif", overwrite=T)
```


\newpage

# Fire deficit / surplus for FRI $\geq$ 40 years

Method from [Clark-Wolf et al 2023](https://iopscience.iop.org/article/10.1088/1748-9326/acee16/meta)

This uses a space-for-time substition to calculate a fire rotation period (FRP), defined as the time it takes to burn an area equal in size to the study area.

$$FRP = \frac{t}{\sum a_i / A} $$

where *t* is the time period evaluated, $a_i$ is annual area burned in year *i*, and *A* is the size of the study area.

This is the contemporary FRP. We can take the mean ecoregion FRI as the historical value. Ecoregion-level deficit / surplus will thus be contemporary divided by historical if contemporary is greater (surplus), or negative historical divided by contemporary if historical is greater (deficit). This makes the number interpretable in the same way as calculated for more frequent fire areas.

**Need a double check here to make sure I've understood this right:** When considering the area *A* and the burned areas $a_i$, I am only considering pixels within the subsetted areas: within the ecoregion, within those areas where FRI \> 40 years, within the vegetation type in question. Same when calculating mean FRI.

All areas with FRI > 40 years, ignoring vegetation type:

```{r create-western-us-longfri-rast}
#| eval: FALSE
#----- Get the CSV data that has fire return interval for all BPS codes ------#
bps <- read.csv("Z:/project_data/landfire data/fire regime/LF2016_FRI_200_CONUS/CSV_Data/LF16_FRI_200.csv")

#----- Filter out those units with an all-fire FRI <= 40 years ---------------#
good_bps <- which(bps$FRI_ALLFIR > 40) 

#----- Replace BPS code with FRI, making NAs for bad FRIs --------------------#
# This matrix will be used to create a FRI raster out of the BPS codes 
# currently stored in the raster
mat <- matrix(c(bps$Value[good_bps], bps$FRI_ALLFIR[good_bps]), 
              nrow=length(good_bps), ncol=2)

fri_crop <- terra::rast("../temp_rasters/fri_crop.tif")
fri <- terra::classify(fri_crop, mat, others=NA)
writeRaster(fri, "../west_us_long_FRI.tif")
```

```{r}
eco <- terra::vect("../Data/level_3_ecoregion/eco_region.shp")
fri <- terra::rast("../west_us_long_FRI.tif")
eco <- terra::project(eco, fri)

#----- Crop level 3 ecoregions to study domain -------------------------------#
eco <- terra::crop(eco, fri)

#----- And to states ---------------------------------------------------------#
eco <- terra::crop(eco, states)

plot(fri, axes=F, 
     main="Study areas with FRI > 40 years, with ecoregions")
plot(eco, add=T, border="red")
```

```{r calculate-ecoregion-fri-veg-area}
#| eval: FALSE

#-----------------------------------------------------------------------------#
# Calculate the area of each veg type within each ecoregion for only those
# areas with a FRI > 40, and calculate the amount of area that has been
# burned. Also calculate the SUM of FRI. These are grid cell counts and are
# not helpful in raw form, but they will help us accurately calculate metrics.
# For instance, sum of FRI is so we can get an average FRI across discontinuous
# ecoregion areas.
#-----------------------------------------------------------------------------#

eco <- terra::vect("../Data/level_3_ecoregion/eco_region.shp")
states <- terra::vect("../Data/s_05mr24.shp")

fri <- terra::rast("../west_us_long_FRI.tif")
num_fires <- terra::rast("../temp_rasters/num_fires.tif") +
             terra::rast("../temp_rasters/num_rx.tif")

eco <- terra::project(eco, fri)
states <- terra::project(states, fri)
states <- terra::crop(states, fri)

#----- Crop level 3 ecoregions to study domain -------------------------------#
eco <- terra::crop(eco, fri)

#----- And to states ---------------------------------------------------------#
eco <- terra::crop(eco, states)

#-----------------------------------------------------------------------------#
# All veg area - for forests, grasslands, and shrublands combined (ignoring
# all else)
#-----------------------------------------------------------------------------#
all_veg <- terra::rast("../temp_rasters/combined_veg_area.tif")

# Make all values 1, so I can easily add and subtract
all_veg <- terra::classify(all_veg, cbind(2:3, c(1,1)), others=NA)

# Create a raster that masks out combined veg area area on long FRIs
good_veg <- fri + all_veg
good_veg <- good_veg - 1 # restoring FRI value

#----- Sum of FRI by ecoregion -----------------------------------------------#
sum_fri <- exactextractr::exact_extract(fri, sf::st_as_sf(eco), fun='sum')

#----- FRP: total area -------------------------------------------------------#
# Create a raster that has 1 for areas where FRI > 40, and NA elsewhere
good_for <- ifel(!is.na(fri), 1, NA)

# Calculate number of cells left in each ecoregion
vv <- exactextractr::exact_extract(good_for, sf::st_as_sf(eco), fun='sum')

#----- How much of this area has burned? -------------------------------------#
good_fire <- good_for + num_fires # Sum to NA out things not in our area
good_fire <- good_fire - 1 # Get rid of the extra 1 from good_for

# Calculate sum of burned cells left in each ecoregion
v2 <- exactextractr::exact_extract(good_fire, sf::st_as_sf(eco), fun='sum')

forest_dat <- data.frame(Name = eco$NA_L3NAME, 
                         Sum_FRI = sum_fri,
                         Total_Area = vv,
                         Area_Burned = v2)
write.csv(forest_dat, "../all_veg_cells_by_ecoregion_long_FRI.csv", row.names = F)


rm(good_veg, all_veg, good_fire)
gc()
#-----------------------------------------------------------------------------#



#-----------------------------------------------------------------------------#
# Forest
#-----------------------------------------------------------------------------#
forest <- terra::rast("../western_us_forest.tif")

# Create a raster that masks out forest area on long FRIs
good_for <- fri + forest
good_for <- good_for - 1 # restoring FRI value

#----- Sum of FRI by ecoregion -----------------------------------------------#
sum_fri <- exactextractr::exact_extract(good_for, sf::st_as_sf(eco), fun='sum')

# Create a raster that has 1 for areas of forest and FRI > 40, and NA elsewhere
# We can start by summing; this will set NAs to NAs for both
good_for <- ifel(!is.na(good_for), 1, NA)

# Calculate number of cells left in each ecoregion
vv <- exactextractr::exact_extract(good_for, sf::st_as_sf(eco), fun='sum')

#----- How much of this area has burned? -------------------------------------#
good_fire <- good_for + num_fires # Sum to NA out things not in our area
good_fire <- good_fire - 1 # Get rid of the extra 1 from good_for

# Calculate sum of burned cells left in each ecoregion
v2 <- exactextractr::exact_extract(good_fire, sf::st_as_sf(eco), fun='sum')

forest_dat <- data.frame(Name = eco$NA_L3NAME, 
                         Sum_FRI = sum_fri,
                         Total_Area = vv,
                         Area_Burned = v2)
write.csv(forest_dat, "../forest_cells_by_ecoregion_long_FRI.csv", row.names = F)


rm(forest, good_for, good_fire)
gc()
#-----------------------------------------------------------------------------#



#-----------------------------------------------------------------------------#
# Grassland
#-----------------------------------------------------------------------------#
grass <- terra::rast("../western_us_grass.tif")

# Create a raster that masks out grass area on long FRIs
good_gr <- fri + grass
good_gr <- good_gr - 1 # restoring FRI value

#----- Sum of FRI by ecoregion -----------------------------------------------#
sum_fri <- exactextractr::exact_extract(good_gr, sf::st_as_sf(eco), fun='sum')

# Create a raster that has 1 for areas of forest and FRI > 40, and NA elsewhere
# We can start by summing; this will set NAs to NAs for both

good_gr <- ifel(!is.na(good_gr), 1, NA)

vv <- exactextractr::exact_extract(good_gr, sf::st_as_sf(eco), fun='sum')

good_fire <- good_gr + num_fires # Sum to NA out things not in our area
good_fire <- good_fire - 1 # Get rid of the extra 1 from good_gr

# Calculate sum of burned cells left in each ecoregion
v2 <- exactextractr::exact_extract(good_fire, sf::st_as_sf(eco), fun='sum')

grass_dat <- data.frame(Name = eco$NA_L3NAME, 
                        Total_Area = vv,
                        Sum_FRI = sum_fri,
                        Area_Burned = v2)
write.csv(grass_dat, "../grass_cells_by_ecoregion_long_FRI.csv", row.names = F)
rm(grass, good_gr, good_fire)
gc()

#-----------------------------------------------------------------------------#
# Shrub
#-----------------------------------------------------------------------------#
shrub <- terra::rast("../western_us_shrub.tif")

# Create a raster that masks out shrub area on long FRIs
good_shrub <- fri + shrub
good_shrub <- good_shrub - 1 # restoring FRI value

#----- Sum of FRI by ecoregion -----------------------------------------------#
sum_fri <- exactextractr::exact_extract(good_shrub, sf::st_as_sf(eco), fun='sum')

# Create a raster that has 1 for areas of forest and FRI > 40, and NA elsewhere
# We can start by summing; this will set NAs to NAs for both
good_shrub <- ifel(!is.na(good_shrub), 1, NA)

vv <- exactextractr::exact_extract(good_shrub, sf::st_as_sf(eco), fun='sum')

good_fire <- good_shrub + num_fires # Sum to NA out things not in our area
good_fire <- good_fire - 1 # Get rid of the extra 1 from good_shrub

shrub_dat <- data.frame(Name = eco$NA_L3NAME, 
                        Total_Area = vv,
                        Sum_FRI = sum_fri,
                        Area_Burned = v2)
write.csv(shrub_dat, "../shrub_cells_by_ecoregion_long_FRI.csv", row.names = F)
rm(shrub, good_shrub)
gc()
#vv <- zonal(good_for, eco, sum, na.rm=T) Too slow
```

```{r calc-area-burned-by-eco-veg}
#| results: asis


hist_time <- 40

#-----------------------------------------------------------------------------#
# Do the FRP calculations by ecoregion. Note that there might be duplicates
# for an ecoregion, as polygons might have been discontinuous
#-----------------------------------------------------------------------------#

cat("## Total area stats\n\n")
#----- All veg ---------------------------------------------------------------#
all_veg_dat <- read.csv("../all_veg_cells_by_ecoregion_long_FRI.csv")

dat <- all_veg_dat %>% group_by(Name) %>% 
  summarise(Area = sum(Total_Area), 
            Burned = sum(Area_Burned),
            FRI_Total = sum(Sum_FRI)) %>%
  filter(Area > 0) %>%
  mutate(FRP = if_else(Burned > 0, hist_time/(Burned/Area), NA)) %>%
  mutate(Mean_FRI = FRI_Total / Area) %>%
  #mutate(Deficit =  (FRP / Mean_FRI) - 1) %>%
  mutate(Deficit = ifelse (FRP > Mean_FRI, FRP / Mean_FRI, -1 * Mean_FRI / FRP)) %>%
  mutate(Area = (Area * prod(res(fri)))/10000,
         Burned = (Burned * prod(res(fri)))/10000) %>%
  select(-FRI_Total)

#----- Make this nice and readable -------------------------------------------#
dat$Area   <- prettyNum(as.character(round(dat$Area, 0))  , big.mark=",")
dat$Burned <- prettyNum(as.character(round(dat$Burned, 0)), big.mark=",")

knitr::kable(dat, col.names = c("Level 3 Ecoregion", 
                                "Total Area (ha)", 
                                "Total Area Burned (ha)",
                                "FRP",
                                "Mean FRI",
                                "Deficit/Surplus"), digits=1)


#----- Forest ----------------------------------------------------------------#
cat("## Forest area stats\n\n")
forest_dat <- read.csv("../forest_cells_by_ecoregion_long_FRI.csv")

dat <- forest_dat %>% group_by(Name) %>% 
  summarise(Area = sum(Total_Area), 
            Burned = sum(Area_Burned),
            FRI_Total = sum(Sum_FRI)) %>%
  filter(Area > 0) %>%
  mutate(FRP = if_else(Burned > 0, hist_time/(Burned/Area), NA)) %>%
  mutate(Mean_FRI = FRI_Total / Area) %>%
  #mutate(Deficit =  (FRP / Mean_FRI) - 1) %>%
  mutate(Deficit = ifelse (FRP > Mean_FRI, FRP / Mean_FRI, -1 * Mean_FRI / FRP)) %>%
  mutate(Area = (Area * prod(res(fri)))/10000,
         Burned = (Burned * prod(res(fri)))/10000) %>%
  select(-FRI_Total)

#----- Make this nice and readable -------------------------------------------#
dat$Area   <- prettyNum(as.character(round(dat$Area, 0))  , big.mark=",")
dat$Burned <- prettyNum(as.character(round(dat$Burned, 0)), big.mark=",")

knitr::kable(dat, col.names = c("Level 3 Ecoregion", 
                                "Total Area (ha)", 
                                "Total Area Burned (ha)",
                                "FRP",
                                "Mean FRI",
                                "Deficit/Surplus"), digits=1)

#----- Grass -----------------------------------------------------------------#
cat("## Grassland area stats\n\n")
grass_dat <- read.csv("../grass_cells_by_ecoregion_long_FRI.csv")

dat <- grass_dat %>% group_by(Name) %>% 
  summarise(Area = sum(Total_Area), 
            Burned = sum(Area_Burned),
            FRI_Total = sum(Sum_FRI)) %>%
  filter(Area > 0) %>%
  mutate(FRP = if_else(Burned > 0, hist_time/(Burned/Area), NA)) %>%
  mutate(Mean_FRI = FRI_Total / Area) %>%
  #mutate(Deficit =  (FRP / Mean_FRI) - 1) %>%
  mutate(Deficit = ifelse (FRP > Mean_FRI, FRP / Mean_FRI, -1 * Mean_FRI / FRP)) %>%
  mutate(Area = (Area * prod(res(fri)))/10000,
         Burned = (Burned * prod(res(fri)))/10000) %>%
  select(-FRI_Total)

#----- Make this nice and readable -------------------------------------------#
dat$Area   <- prettyNum(as.character(round(dat$Area, 0))  , big.mark=",")
dat$Burned <- prettyNum(as.character(round(dat$Burned, 0)), big.mark=",")

knitr::kable(dat, col.names = c("Level 3 Ecoregion", 
                                "Total Area (ha)", 
                                "Total Area Burned (ha)",
                                "FRP",
                                "Mean FRI",
                                "Deficit/Surplus"), digits=1)

#----- Shrubs ----------------------------------------------------------------#
cat("## Shrubland area stats\n\n")
shrub_dat <- read.csv("../shrub_cells_by_ecoregion_long_FRI.csv")

dat <- shrub_dat %>% group_by(Name) %>% 
  summarise(Area = sum(Total_Area), 
            Burned = sum(Area_Burned),
            FRI_Total = sum(Sum_FRI)) %>%
  filter(Area > 0) %>%
  mutate(FRP = if_else(Burned > 0, hist_time/(Burned/Area), NA)) %>%
  mutate(Mean_FRI = FRI_Total / Area) %>%
  #mutate(Deficit =  (FRP / Mean_FRI) - 1) %>%
  mutate(Deficit = ifelse (FRP > Mean_FRI, FRP / Mean_FRI, -1 * Mean_FRI / FRP)) %>%
  mutate(Area = (Area * prod(res(fri)))/10000,
         Burned = (Burned * prod(res(fri)))/10000) %>%
  select(-FRI_Total)

#----- Make this nice and readable -------------------------------------------#
dat$Area   <- prettyNum(as.character(round(dat$Area, 0))  , big.mark=",")
dat$Burned <- prettyNum(as.character(round(dat$Burned, 0)), big.mark=",")

knitr::kable(dat, col.names = c("Level 3 Ecoregion", 
                                "Total Area (ha)", 
                                "Total Area Burned (ha)",
                                "FRP",
                                "Mean FRI",
                                "Deficit/Surplus"), digits=1)
```

```{r make-long-fri-ecoregions-shapefile}
#| eval: false
#-----------------------------------------------------------------------------#
# Prep ecoregions shapefile; we will add deficit values directly to the 
# shapefile
#-----------------------------------------------------------------------------#
eco <- terra::vect("../Data/level_3_ecoregion/eco_region.shp")
states <- terra::vect("../Data/s_05mr24.shp")

fri <- terra::rast("../west_us_long_FRI.tif")
eco <- terra::project(eco, fri)
states <- terra::project(states, fri)
states <- terra::crop(states, fri)

#----- Crop level 3 ecoregions to study domain -------------------------------#
eco <- terra::crop(eco, fri)

#----- And to states ---------------------------------------------------------#
eco <- terra::crop(eco, states)

hist_time <- 40

#-----------------------------------------------------------------------------#
# Do the FRP calculations by ecoregion. Note that there might be duplicates
# for an ecoregion, as polygons might have been discontinuous
#-----------------------------------------------------------------------------#

#----- All veg ---------------------------------------------------------------#
all_veg_dat <- read.csv("../all_veg_cells_by_ecoregion_long_FRI.csv")

dat <- all_veg_dat %>% group_by(Name) %>% 
  summarise(Area = sum(Total_Area), 
            Burned = sum(Area_Burned),
            FRI_Total = sum(Sum_FRI)) %>%
  filter(Area > 0) %>%
  mutate(FRP = if_else(Burned > 0, hist_time/(Burned/Area), NA)) %>%
  mutate(Mean_FRI = FRI_Total / Area) %>%
  mutate(Deficit = ifelse (FRP > Mean_FRI, FRP / Mean_FRI, -1 * Mean_FRI / FRP)) %>%
  mutate(Area = (Area * prod(res(fri)))/10000,
         Burned = (Burned * prod(res(fri)))/10000) %>%
  select(-FRI_Total)

eco$allveg_def <- NA
ind <- match(eco$NA_L3NAME, dat$Name)
eco$allveg_def <- dat$Deficit[ind]

#----- Forest ----------------------------------------------------------------#
forest_dat <- read.csv("../forest_cells_by_ecoregion_long_FRI.csv")

dat <- forest_dat %>% group_by(Name) %>% 
  summarise(Area = sum(Total_Area), 
            Burned = sum(Area_Burned),
            FRI_Total = sum(Sum_FRI)) %>%
  filter(Area > 0) %>%
  mutate(FRP = if_else(Burned > 0, hist_time/(Burned/Area), NA)) %>%
  mutate(Mean_FRI = FRI_Total / Area) %>%
  mutate(Deficit = ifelse (FRP > Mean_FRI, FRP / Mean_FRI, -1 * Mean_FRI / FRP)) %>%
  mutate(Area = (Area * prod(res(fri)))/10000,
         Burned = (Burned * prod(res(fri)))/10000) %>%
  select(-FRI_Total)

eco$forest_def <- NA
ind <- match(eco$NA_L3NAME, dat$Name)
eco$forest_def <- dat$Deficit[ind]

#----- Grass -----------------------------------------------------------------#
grass_dat <- read.csv("../grass_cells_by_ecoregion_long_FRI.csv")

dat <- grass_dat %>% group_by(Name) %>% 
  summarise(Area = sum(Total_Area), 
            Burned = sum(Area_Burned),
            FRI_Total = sum(Sum_FRI)) %>%
  filter(Area > 0) %>%
  mutate(FRP = if_else(Burned > 0, hist_time/(Burned/Area), NA)) %>%
  mutate(Mean_FRI = FRI_Total / Area) %>%
  mutate(Deficit = ifelse (FRP > Mean_FRI, FRP / Mean_FRI, -1 * Mean_FRI / FRP)) %>%
  mutate(Area = (Area * prod(res(fri)))/10000,
         Burned = (Burned * prod(res(fri)))/10000) %>%
  select(-FRI_Total)

eco$grass_def <- NA
ind <- match(eco$NA_L3NAME, dat$Name)
eco$grass_def <- dat$Deficit[ind]

#----- Shrubs ----------------------------------------------------------------#
shrub_dat <- read.csv("../shrub_cells_by_ecoregion_long_FRI.csv")

dat <- shrub_dat %>% group_by(Name) %>% 
  summarise(Area = sum(Total_Area), 
            Burned = sum(Area_Burned),
            FRI_Total = sum(Sum_FRI)) %>%
  filter(Area > 0) %>%
  mutate(FRP = if_else(Burned > 0, hist_time/(Burned/Area), NA)) %>%
  mutate(Mean_FRI = FRI_Total / Area) %>%
  mutate(Deficit = ifelse (FRP > Mean_FRI, FRP / Mean_FRI, -1 * Mean_FRI / FRP)) %>%
  mutate(Area = (Area * prod(res(fri)))/10000,
         Burned = (Burned * prod(res(fri)))/10000) %>%
  select(-FRI_Total)

#----- Make this nice and readable -------------------------------------------#
dat$Area   <- prettyNum(as.character(round(dat$Area, 0))  , big.mark=",")
dat$Burned <- prettyNum(as.character(round(dat$Burned, 0)), big.mark=",")

eco$shrub_def <- NA
ind <- match(eco$NA_L3NAME, dat$Name)
eco$shrub_def <- dat$Deficit[ind]

terra::writeVector(eco, "../temp_rasters/ecoregions_with_deficit.shp", overwrite=T)

#----- Now rasters of all these ----------------------------------------------#
def_rast <- rast(fri)
allvegrast <- rasterize(eco, def_rast, field = "allveg_def", touches = TRUE)
terra::writeRaster(allvegrast, "../temp_rasters/eco_all_veg_def.tif", overwrite=T)

forestrast <- rasterize(eco, def_rast, field = "forest_def", touches = TRUE)
terra::writeRaster(forestrast, "../temp_rasters/eco_forest_def.tif", overwrite=T)

grassrast <- rasterize(eco, def_rast, field = "grass_def", touches = TRUE)
terra::writeRaster(grassrast, "../temp_rasters/eco_grass_def.tif", overwrite=T)

shrubrast <- rasterize(eco, def_rast, field = "shrub_def", touches = TRUE)
terra::writeRaster(shrubrast, "../temp_rasters/eco_shrub_def.tif", overwrite=T )
#plot(rasterized,range=c(0,10),
#     fill_range=T)
```

\newpage

# Appendix - Landfire FRI documentation

The most recent data for CONUS is 2016. For Alaska it is 2023. Considering that the previous AK dataset is 2001, I will go ahead and use the most recent data for both even though they are not from the same timeframe.

There are 4 possible fire return interval codes:

-   Fire Return Interval (FRI) replacement fire (FRI_REPLAC)
-   Fire Return Interval mixed fire (FRI_MIXED)
-   Fire Return Interval surface fire (FRI_SURFAC)
-   Fire Return Interval all fire. Quantifies the average period between fires under the presumed historical fire regime. Previously Mean Fire Return Interval (MFRI) (FRI_ALLFIR)

From the metadata for the fire return interval product:

> The Fire Return Interval (FRI) product quantifies the average period between fires under the presumed historical fire regime. FRI is intended to describe one component of historical fire regime characteristics in the context of the broader historical time period represented by the LANDFIRE Biophysical Settings (BpS) product and BpS Model documentation. To learn more about FRI go to https://landfire.gov/fire-regime/fri. At the release of LF 2016 Remap Fire Regime Groups (FRG_NEW), Percent of Low-severity Fire (PRC_SURFAC), Percent of Mixed-severity Fire (PRC_MIXED), Percent of Replacement-severity Fire (PRC_REPLAC), and Fire Return Interval (FRI_ALLFIR) were included as attributes in the Biophysical Settings (BPS) product. Then in 2024 these products became stand-alone products once again. With the 3 Percent Severity products merged into a single product called Percent Fire Severity (PFS). These products can now be found in both places, as attributes of BPS and as their own individual products.

> LF 2016 Remap (LF Remap) is a comprehensive mapping effort that uses recent data to create a new base map product suite that better represents contemporary conditions. LF Remap represents circa 2016 ground conditions and is designed to produce vegetation, disturbance, and fuels products that inform wildland fire and ecological decision systems. LF Remap has improved past methodologies and processes to incorporate current satellite imagery, contemporary data sources, and the latest software and hardware technologies. Final LF Remap products offer significant improvements to all previous LF versions (read more about versions here https://www.landfire.gov/lf_schedule.php). LF Remap products are designed to facilitate national and regional level strategic fire and resource management planning and reporting of management activities. The principal purposes of the products include providing, 1) national level, landscape scale geospatial products to support fire and fuels management planning, and 2) consistent fuels products to support fire planning, analysis, and budgeting to evaluate fire management alternatives. Products are created at a 30 meter raster; however, the applicability of products varies by location and specific use. LF products were designed to support 1) national (all states) strategic planning, 2) regional (single large states or groups of smaller states), and 3) strategic/tactical planning for large sub regional landscapes and Fire Management Units (FMUs) (such as significant portions of states or multiple federal administrative entities). The applicability of LF products to support fire and land management planning on smaller areas will vary by product, location, and specific use. Managers and planners must evaluate LF products according to the scale and requirements specific to their needs.

## Where does FRI come from?

We want to know the inputs into the fire regime maps to know what we can make them say. For instance, if FRI is partially modeled based on vegetation type, it makes no sense to do analysis comparing FRI to vegetation type because OF COURSE they will correlate.

From the technical documentation:

> "The fire return intervals and percentage of expected severity for pre-European fire regimes were revised from LF National with updated BpS \[biophysical settings\] descriptions. The descriptions were updated with the input of more than 800 experts around the country during 5 years of workshops (Blankenship and others, 2021)."

The full citation: Blankenship, K., Swaty, R., Hall, K.R., Hagen, S., Pohl, K., Shlisky Hunt, A., Patton, J., Frid, L., and Smith, J., 2021, Vegetation dynamics models—A comprehensive set for natural resource assessment and planning in the United States: Ecosphere, v. 12, no. 4, art. e03484, 22 p. <https://doi.org/10.1002/ecs2.3484>

Notes from Blankenship et al:

> We stratified vegetation systems according to LANDFIRE's Biophysical Setting (BpS) classification system (Rollins 2009). Models for each BpS and their accompanying description documents (collectively referred to as the BpS model library) synthesize fundamental ecological information about ecosystem dynamics, structure, composition, and disturbance regimes.

> The BpS model library—developed collaboratively by more than 800 experts—includes over 900 vegetation dynamic models and associated BpS descriptions for different terrestrial vegetation communities covering the USA and its territories ([LANDFIRE 2020a](https://esajournals.onlinelibrary.wiley.com/doi/10.1002/ecs2.3484#ecs23484-bib-0037)).

> To support the goal of providing data to prioritize fire and fuel management activities, LANDFIRE developed historical reference conditions for vegetation composition and fire regimes using a simulation modeling approach. While the details of the approach varied slightly between different Program development phases, vegetation dynamic models, called state-and-transition simulation models (STSMs), were a key component of all phases (Appendix S1). STSMs divide an ecosystem into discrete states linked by pathways that define the rates of growth and frequency and effects of disturbances ([https://besjournals.onlinelibrary.wiley.com/doi/10.1111/2041-210X.12597](Daniel%20et%20al.%202016)). LANDFIRE used STSMs to estimate reference fire regime and vegetation conditions. Then using a similarity index, called vegetation condition class (Barrett et al. 2010), the Program measured the difference between its modeled historical vegetation reference conditions and current conditions mapped from satellite imagery (Rollins 2009).

> Because literature alone was insufficient to fully parameterize a set of STSMs that could represent the breadth of ecosystems across the USA (Long et al. 2006), LANDFIRE chose an expert-based approach to develop the BpS model library. The Program identified a set of modeling leaders, including the authors, to coordinate the effort. We invited experienced land and fire managers, natural resource specialists, biologists, ecologists, and others with knowledge of ecosystem composition, structure, and disturbance regimes to collaborate and co-create a national BpS model library.

> Each LANDFIRE STSM and its accompanying narrative represents a BpS—a potential vegetation concept reflecting the native vegetation community that was likely to have existed in the pre-settlement reference period, based on an approximation of historical disturbance regimes and the current biophysical environment ([https://www.publish.csiro.au/wf/WF08088](Rollins%202009)).

> In workshops and follow-up efforts, modeling leaders and developers conceived an STSM for each BpS by dividing it into states (also called succession classes) and defining the causes and rates of transitions between them (Fig. 2). Models were initially developed in the Vegetation Dynamics Development Tool (ESSA 2007) and later in SyncroSim's ST-Sim package (ApexRMS 2019; Appendix S1). Both are flexible and free software platforms for developing STSMs.

> To describe how vegetation transitioned among the various states, model developers defined growth and disturbance pathways for each STSM and represented these processes as deterministic or probabilistic transitions. Model developers used deterministic transitions to represent growth or successional trajectories and probabilistic transitions to represent disturbances. Given LANDFIRE's use of the STSMs to define reference fire regimes, we asked model developers to further specify fire transitions by severity class based on the percent top-kill of the upper vegetation canopy: 0–25% for surface, 25–75% for mixed, and greater than 75% for replacement severity. Model developers included all important system drivers, such as those that could have delayed natural succession or caused a transition to a new state as they built and tested their STSMs.

> Model developers ran each STSM to estimate how the set of states and transitions they had specified for a BpS resulted in an equilibrium state distribution and fire regime under pre-settlement conditions (i.e., the LANDFIRE reference condition).

![A LANDFIRE STSM represents the vegetation dynamics of a BpS. This graphic representation of the Inter-Mountain Basins Big Sagebrush Steppe BpS STSM (LANDFIRE 2020d) shows the rate of growth between states and the frequency and impact of disturbances. Each state represents a discrete developmental stage defined by its vegetation cover, structure, and age range. The impact and frequency of disturbances is described by the starting and ending state and an annual probability of occurrence indicated by the value associated with each probabilistic transition pathway. All fires in this STSM are considered replacement fires following LANDFIRE's definition because over 75% of the dominant herbaceous and shrub species in this BpS are top-killed by fire.](figs/stsm_fig.png)

> To produce a set of STSMs with comparable levels of detail across the country and to ensure compatibility with other LANDFIRE products, we designed modeling rules, such as restricting model developers to defining five or fewer states (Appendix S5: Table S1). In addition, we standardized and constrained the software functions available to model developers to help ensure consistency in outputs and facilitate quality checking hundreds of STSMs (Appendix S5: Table S2). Advanced modeling functions, such as simulating temporal variability in disturbance regimes, were prohibited because they required additional data that were unavailable for most locations and disturbance types.

\newpage

# Appendix - LANDFIRE Fire Regime Group Codes (FRG)

| FRG_NEW | Fire Regime Group |
|------------------------|-----------------------------------------------|
| I-A | Percent replacement fire less than 66.7%, fire return interval 0 to 5 years. |
| I-B | Percent replacement fire less than 66.7%, fire return interval 6 to 15 years. |
| I-C | Percent replacement fire less than 66.7%, fire return interval 16 to 35 years. |
| II-A | Percent replacement fire greater than 66.7%, fire return interval 0 to 5 years. |
| II-B | Percent replacement fire greater than 66.7%, fire return interval 6 to 15 years. |
| II-C | Percent replacement fire greater than 66.7%, fire return interval 16 to 35 years. |
| III-A | Percent replacement fire less than 80%, fire return interval 36 to 100 years. |
| III-B | Percent replacement fire less than 66.7%, fire return interval 101 to 200 years. |
| IV-A | Percent replacement fire greater than 80%, fire return interval 36 to 100 years. |
| IV-B | Percent replacement fire greater than 66.7%, fire return interval 101 to 200 years. |
| V-A | Any severity, fire return interval 201 to 500 years. |
| V-B | Any severity, fire return interval 501 or more years. |

\newpage

# Appendix - vegetation type documentation

## Landfire Existing Vegetation Cover (EVC)

### Lifeform Modeling

From the technical documentation, on how vegetation cover is assigned:

The first step for vegetation modeling and mapping was to separate the landscape into three lifeforms: herbaceous, shrub, and treed areas. Each LFRDB plot is assigned to one of these three dominant physiognomic or lifeform types based on the assigned EVT–ES label derived from the Auto-Key.

A common occurrence that arose during the LF 2016 Remap effort was the assignment of multiple lifeforms to a given ES. These types and their associated lifeform options were identified before modeling with assistance from Nature-Serve and comparison to previous products. Where feasible, plots for these types were reassigned the appropriate lifeform using species absolute cover information from the LFRDB. Table and field descriptions are available in the LFRDB data dictionary (LANDFIRE, 2021b).

Lifeform cover was derived from LFTreeCov, LFShrubCov, and LFHerbCov fields in the stands table using the following logic:

-   If both tree and shrub lifeforms were present in a plot and tree cover was greater than or equal to ($\geq$) 10-percent, it was assigned tree, otherwise shrub.

-   If both tree and herbaceous lifeforms were present in a plot and shrub cover was $\geq$ 10-percent, it was assigned shrub, otherwise herbaceous.

-   If no cover was present for the plot, then the higher lifeform of the options (the dominant lifeform) was assigned.

### Complete cover class listing for LANDFIRE

```{r}
evc_codes <- read.csv("Z:/project_data/landfire data/vegetation/existing vegetation cover/LF2016_EVC_200_CONUS/CSV_Data/LF16_EVC_200.csv")
knitr::kable(evc_codes[,1:2])
```

\newpage

## Cover class listing for LCMS

1: TREES: The majority of the pixel is comprised of live or standing dead trees.

2: TALL SHRUBS AND TREES MIX: (SEAK Only) The majority of the pixel is comprised of shrubs greater than 1m in height and is also comprised of at least 10 percent live or standing dead trees.

3: SHRUBS AND TREES MIX: The majority of the pixel is comprised of shrubs and is also comprised of at least 10 percent live or standing dead trees.

4: GRASS/FORB/HERB AND TREES MIX: The majority of the pixel is comprised of perennial grasses, forbs, or other forms of herbaceous vegetation and is also comprised of at least 10 percent live or standing dead trees.

5: BARREN AND TREES MIX: The majority of the pixel is comprised of bare soil exposed by disturbance (e.g., soil uncovered by mechanical clearing or forest harvest), as well as perennially barren areas such as deserts, playas, rock outcroppings (including minerals and other geologic materials exposed by surface mining activities), sand dunes, salt flats, and beaches. Roads made of dirt and gravel are also considered barren and is also comprised of at least 10 percent live or standing dead trees.

6: TALL SHRUBS: (SEAK Only) The majority of the pixel is comprised of shrubs greater than 1m in height.

7: SHRUBS: The majority of the pixel is comprised of shrubs.

8: GRASS/FORB/HERB AND SHRUBS MIX: The majority of the pixel is comprised of perennial grasses, forbs, or other forms of herbaceous vegetation and is also comprised of at least 10 percent shrubs.

9: BARREN AND SHRUBS MIX: The majority of the pixel is comprised of bare soil exposed by disturbance (e.g., soil uncovered by mechanical clearing or forest harvest), as well as perennially barren areas such as deserts, playas, rock outcroppings (including minerals and other geologic materials exposed by surface mining activities), sand dunes, salt flats, and beaches. Roads made of dirt and gravel are also considered barren and is also comprised of at least 10 percent shrubs.

10: GRASS/FORB/HERB: The majority of the pixel is comprised of perennial grasses, forbs, or other forms of herbaceous vegetation.

11: BARREN AND GRASS/FORB/HERB MIX: The majority of the pixel is comprised of bare soil exposed by disturbance (e.g., soil uncovered by mechanical clearing or forest harvest), as well as perennially barren areas such as deserts, playas, rock outcroppings (including minerals and other geologic materials exposed by surface mining activities), sand dunes, salt flats, and beaches. Roads made of dirt and gravel are also considered barren and is also comprised of at least 10 percent perennial grasses, forbs, or other forms of herbaceous vegetation.

12: BARREN OR IMPERVIOUS: The majority of the pixel is comprised of 1) bare soil exposed by disturbance (e.g., soil uncovered by mechanical clearing or forest harvest), as well as perennially barren areas such as deserts, playas, rock outcroppings (including minerals and other geologic materials exposed by surface mining activities), sand dunes, salt flats, and beaches. Roads made of dirt and gravel are also considered barren or 2) man-made materials that water cannot penetrate, such as paved roads, rooftops, and parking lots.

13: SNOW OR ICE: The majority of the pixel is comprised of snow or ice.

14: WATER: The majority of the pixel is comprised of water.

15: NON-PROCESSING AREA MASK: Where no cloud or cloud shadow-free data are available to produce an output.

\newpage

### LCMAP Primary Land Cover (LCPRI)

From the docs:

> The need for improved understanding and management of land surface change requires increased understanding of the basic drivers of change, identification of potential consequences of change on human and natural systems, and greater insight into the impacts and feedbacks of climate change. The geospatial community requires a new generation of monitoring data and information to meet this need for a wide range of applications. Land cover and land change products need to span larger geographic extents, over longer time periods, at higher spatial resolutions, and provide more systematic and consistent information on change than ever before. To help meet these growing demands, the United States Geological Survey (USGS) has developed the Land Change Monitoring, Assessment, and terra::projection (LCMAP) initiative.

This is based on the National Land Cover Database (NLCD), and looks to be currently deprecated in favor of the NLCD.

| Pixel Value | Land Cover Class |
|-------------|------------------|
| 1           | Developed        |
| 2           | Cropland         |
| 3           | Grass/Shrub      |
| 4           | Tree Cover       |
| 5           | Water            |
| 6           | Wetland          |
| 7           | Ice/Snow         |
| 8           | Barren           |

\newpage

# Appendix - evolution of methods

My first raster products were clipped to the 100th line of longitude instead of to the study domain. There is an email note where this is referenced.

The current vegetation class definitions were the result of some trial and error, and comparison with other vegetation products. Vegetation class definitions were initially based on Landfire EVC, and we elected to keep that basis.

## For forest:

EVC cover classes of interest:

-   Developed-upland deciduous forest
-   Developed-upland evergreen forest
-   Developed-upland mixed forest
-   Tree cover - 10% to 93%

The developed classes are based on National Landcover Database areas classified as "developed open space". The complete definition, from NLCD:

> Developed, Open Space- areas with a mixture of some constructed materials, but mostly vegetation in the form of lawn grasses. Impervious surfaces account for less than 20% of total cover. These areas most commonly include large-lot single-family housing units, parks, golf courses, and vegetation planted in developed settings for recreation, erosion control, or aesthetic purposes.

From the LANDFIRE technical documentation:

> NLCD class 21 (developed open space) was made “burnable” by splitting it into five “burnable urban” classes that capture the variety of lifeform (herb, shrub, tree) and leaf form (deciduous, evergreen, mixed) across the open space designation\[...\].

Based on this, I proposed a definition of "forest cover" as the three developed forest classes, plus those areas where tree cover is greater than 50%.

### Comparing this forest coverage to other forest coverage

We'd like to compare forest to the two forest products used by Jennifer Balch's team in the good fire analysis. About that, Mahsa says:

> The forest data that they used is a combination of LCMS (landscape change monitoring system) and LCPRI (LCMAP Primary Land Cover). Technically, for this analysis, we need to evaluate each fire year using separate forest maps corresponding to that specific year. So, they didn’t use just one map for the analysis; instead, it’s a different forest map for each year. We use and analyze these image collections directly on Google Earth Engine (GEE). So the data used is multi-year LCMS and LCPRI, which are available both in GEE and their website.

> Jennifer's team defined forested regions as areas where LCPRI equals 4 and LCMS equals 1.

Let's compare 2016 data for these two products to ours.

```{r crop-lcpri-rast-to-western-us}
#| eval: false
lcpri <- terra::rast("../Data/Balch forest cover/LCMAP_CU_2016_V13_LCPRI.tif")
study_domain <- terra::rast("../temp_rasters/study_domain.tif")
lcpri_crop <- terra::crop(lcpri, study_domain)
lcpri_crop <- terra::mask(lcpri_crop, study_domain)
rm(lcpri)
invisible(gc())

writeRaster(lcpri_crop, "../temp_rasters/lcpri_crop.tif")
```

```{r create-lcpri-western-us-forest-rast}
#| eval: false
lcpri_crop <- terra::rast("../temp_rasters/lcpri_crop.tif")
lcpri_crop <- terra::classify(lcpri_crop, cbind(4,1), others=NA)
writeRaster(lcpri_crop, "../temp_rasters/lcpri_forest.tif")
```

```{r results='asis'}
lcms <- terra::rast("../temp_rasters/lcms_forest.tif")
plot(lcms, axes=F, main="LCMS forest cover", col="darkgreen", legend = F)
plot(states, add=T, fill=NULL)
rm(lcms)
invisible(gc())

cat("\n\n")

lcpri <- terra::rast("../temp_rasters/lcpri_forest.tif")
plot(lcpri, axes=F, main="LCPRI forest cover", col="darkgreen", legend = F)
plot(states, add=T, fill=NULL)
rm(lcpri)
invisible(gc())
```

```{r}
#-----------------------------------------------------------------------------#
# Comparison of forest products
#-----------------------------------------------------------------------------#
#evc   <- terra::rast("evc_forest.tif")
#lcms  <- terra::rast("lcms_forest.tif")
#lcpri <- terra::rast("lcpri_forest.tif")

#x <- freq(evc)
#evc_forest_area <- (x$count * prod(res(evc)))/10000
evc_forest_area <- 26649906

#x <- freq(lcms)
#lcms_forest_area <- (x$count * prod(res(lcms)))/10000
lcms_forest_area <- 79246265

#x <- freq(lcpri)
#lcpri_forest_area <- (x$count * prod(res(lcpri)))/10000
lcpri_forest_area <- 70939594


knitr::kable(
  data.frame("raster" = c("Landfire EVC", "LCMS", "LCPRI"),
             "Area" = c(prettyNum(evc_forest_area, big.mark=","), 
                        prettyNum(lcms_forest_area, big.mark=","),
                        prettyNum(lcpri_forest_area, big.mark=","))),
  col.names = c("Forest product", "Area (ha)"))
```

```{r create-three-way-forest-comparison}
#| eval: false
evc   <- terra::rast("../temp_rasters/evc_forest.tif")
lcms  <- terra::rast("../temp_rasters/lcms_forest.tif")
lcpri <- terra::rast("../temp_rasters/lcpri_forest.tif")

all <- sum(evc, lcms, lcpri, na.rm=T)
writeRaster(all, "../temp_rasters/forest_tally.tif")
```

```{r}
all <- terra::rast("../temp_rasters/forest_tally.tif")
plot(all, axes=F, main="How many products say this place is forest?")
plot(states, add=T, fill=NULL)
```

This implies that our definition of "forest" is quite a bit stricter than the one used by Jennifer Balch. So let's see if we can see how to align them (whether or not we decide to actually do so). Let's say that all tree cover $\geq$ 20% is forest.

```{r create-looser-evc-forest-rast}
#| eval: FALSE
#----- Get the CSV data with vegetation codes --------------------------------#
evc_codes <- read.csv("Z:/project_data/landfire data/vegetation/existing vegetation cover/LF2016_EVC_200_CONUS/CSV_Data/LF16_EVC_200.csv")

#----- Filter forest cover ---------------------------------------------------#
good_codes <- grep("Forest", evc_codes$CLASSNAMES)
good_codes <- c(good_codes, grep("Tree Cover = 2.*", evc_codes$CLASSNAMES))
good_codes <- c(good_codes, grep("Tree Cover = 3.*", evc_codes$CLASSNAMES))
good_codes <- c(good_codes, grep("Tree Cover = 4.*", evc_codes$CLASSNAMES))
good_codes <- c(good_codes, grep("Tree Cover = 5.*", evc_codes$CLASSNAMES))
good_codes <- c(good_codes, grep("Tree Cover = 6.*", evc_codes$CLASSNAMES))
good_codes <- c(good_codes, grep("Tree Cover = 7.*", evc_codes$CLASSNAMES))
good_codes <- c(good_codes, grep("Tree Cover = 8.*", evc_codes$CLASSNAMES))
good_codes <- c(good_codes, grep("Tree Cover = 9.*", evc_codes$CLASSNAMES))
good_codes <- c(good_codes, grep("Tree Cover >= 99.*", evc_codes$CLASSNAMES))
good_codes <- c(good_codes)

#----- Make a forest cover mask - 1 if in cover, 0 if not --------------------#
mat <- matrix(c(evc_codes$VALUE[good_codes], rep(1, length(good_codes))), 
              nrow=length(good_codes), ncol=2)

evc_crop <- terra::rast("../temp_rasters/evc_crop.tif")
evc <- terra::classify(evc_crop, mat, others=NA)
rm(evc_crop)
gc()
writeRaster(evc, "../temp_rasters/evc_forest_loose.tif", overwrite = TRUE)
```

```{r}
evc <- terra::rast("../temp_rasters/evc_forest_loose.tif")
#x <- freq(evc)
#evc_forest_area <- (x$count * prod(res(evc)))/10000
evc_forest_area <- 73571515

plot(evc, axes=F, legend=F, col="darkgreen",
     main=paste("EVC Looser Forest Definition -", 
                prettyNum(evc_forest_area, big.mark=","), "ha"))
plot(states, add=T, fill=NULL)
```

## For grassland:

Continuing with the Landfire EVC product - cover classes for grassland. I will assume that for fire fuel purposes, grain crops will **not** be counted in this category.

Mixed cover classes are hard! Let's try:

-   Developed-Upland Herbaceous
-   Developed - Open Space (*not entirely sure on this one*)
-   Herb cover 20-90%

The documentation states that the highest lifeform gets the class assignment, with the order being tree, shrub, herbaceous. If something is classed as herbaceous, the way I read that, there is less than 10% of either trees or shrubs present. **Do we assume that if herb cover is 10%, the other 90% of cover is essentially barren?** On the assumption that that is possible, I will not include herb cover \< 20% (*higher?*)

As before, let us compare with the other landcover products we have. For LCMS, let's say that grassland is only GRASS/FORB/HERB.

I will leave out GRASS/FORB/HERB AND TREES MIX, because it is at least 10% tree cover.

I will leave out GRASS/FORB/HERB AND SHRUBS MIX, semi-arbitrarily? But under the assumption that if it is included anywhere, this will go in our shrubland classification.

I will leave out BARREN AND GRASS/FORB/HERB MIX, although this might match up with our scanty herb cover classes.

LCPRI has one "Cropland" and one "Grass/Shrub" cover class. Since this does not split out grass and shrubs as we require, drop this for now.

```{r}
#| results: asis

evc <- terra::rast("../temp_rasters/evc_grass.tif")
#x <- freq(evc)
#evc_grass_area <- (x$count * prod(res(evc)))/10000
#evc_grass_area <- 78078768 with crops
evc_grass_area <- 60114973#
plot(evc, axes=F,  legend = F, col = "darkgoldenrod3",
     main=paste("Landfire EVC West US Grass Cover -", 
                prettyNum(evc_grass_area, big.mark=","), "ha"))
plot(states, add=T, fill=NULL)
rm(evc)
invisible(gc())

cat("\n\n")

lcms <- terra::rast("../temp_rasters/lcms_grass.tif")
x <- freq(lcms)
lcms_grass_area <- (x$count * prod(res(lcms)))/10000
#lcms_grass_area <- 160156968 with GRASS/FORB/HERB AND SHRUBS MIX
lcms_grass_area <- 67670210
plot(lcms, axes=F,  legend = F, col = "darkgoldenrod3",
     main=paste("LCMS West US Grass Cover -", 
                prettyNum(lcms_grass_area, big.mark=","), "ha"))
plot(states, add=T, fill=NULL)
rm(lcms)
invisible(gc())
```

Extra grass area from LCMS appears to be largely what Landfire has classified as cropland, based on visual inspection but not quantification.

\newpage

## For shrub/chaparral:

Continuing with the Landfire EVC product - cover classes for shrubland.

-   Developed-Upland Shrubland
-   Shrub cover 20-90% (although actual values only appear up to 79%)

## Issues

Same issue as grass: if shrubs are 10% of cover, what is the rest? Not trees, or it would be tree cover. It is probably grass or barren or some combination. I will omit covers below 20%, fairly arbitrarily.

Compare with LCMS. Again, we have a lot of mixed classes that may or may not count here. Let's say that these classes are shrubland:

-   GRASS/FORB/HERB AND SHRUBS MIX (this is at least 10% shrubs)
-   TALL SHRUBS
-   SHRUBS

Other possibilities that I am omitting in this version: TALL SHRUBS AND TREES MIX, SHRUBS AND TREES MIX, BARREN AND SHRUBS MIX

```{r}
#| results: asis

evc <- terra::rast("../temp_rasters/evc_shrub.tif")
#x <- freq(evc)
#evc_shrub_area <- (x$count * prod(res(evc)))/10000
evc_shrub_area <- 123684737
plot(evc, axes=F,  legend = F, col = "burlywood4",
     main=paste("Landfire EVC West US Shrub Cover -", 
                prettyNum(evc_shrub_area, big.mark=","), "ha"))
plot(states, add=T, fill=NULL)
rm(evc)
invisible(gc())

cat("\n\n")

lcms <- terra::rast("../temp_rasters/lcms_shrub.tif")
#x <- freq(lcms)
#lcms_shrub_area <- (x$count * prod(res(lcms)))/10000
lcms_shrub_area <- 104228761
plot(lcms, axes=F,  legend = F, col = "burlywood4",
     main=paste("LCMS West US Shrub Cover -", 
                prettyNum(lcms_shrub_area, big.mark=","), "ha"))
plot(states, add=T, fill=NULL)
rm(lcms)
invisible(gc())
```

Disagreement between these rasters appears to be based on how much barren land is acceptable, and where mixed classes fall.

We eventually determined that LCMS did a pretty bad job of differentiating between shrubs and trees, identifying lots of shrubland in southern California as forest, so we gave it up as a bad job for our main rasters and thanked it for its service in helping validate cover choices.

```{r archive-crop}
#| eval: FALSE

#-----------------------------------------------------------------------------#
# This was the first thing I tried, but Winslow said I went too far east and
# gave me a study domain raster to use instead.
#-----------------------------------------------------------------------------#

#----- Load the BPS raster ---------------------------------------------------#
fri <- terra::rast("Z:/project_data/landfire data/fire regime/LF2016_FRI_200_CONUS/Tif/LC16_FRI_200.tif")

#----- Crop to bounding box of Western US ------------------------------------#
# This is for WFFRC so split along line of 100 degrees west longitude
# I did this exercise and did a transformation so I know the number in 
# the FRI terra::projection
#west_us <- terra::vect(ext(-125, -100, 27, 49.5), crs="+proj=longlat +datum=WGS84")
split_longitude <- 293952
west_us <- terra::vect(matrix(c(ext(fri)$xmin,   ext(fri)$ymin, 
                                ext(fri)$xmin,   ext(fri)$ymax, 
                                split_longitude, ext(fri)$ymin, 
                                split_longitude, ext(fri)$ymax, 
                                ext(fri)$xmin,   ext(fri)$ymin),
                              ncol = 2, byrow = TRUE), type = "polygons", 
                       crs = crs(fri))

fri_crop <- terra::crop(fri, west_us)
```

\newpage

# Appendix - communications and directives

### From Winslow, via Slack, 12/6/2024, kicking things off:

> Moore program officers wanted us to calculate a 30 m fire deficit/fire surplus product for western US forests. I don't think that's possible for all western forests. But I do think think its possible to do 2 things.

> 1.  calculate fire deficit and surplus for all counties and level 3 ecoregions in CONUS and Alaska and then calculate fire deficit at a 30-m resolution where the historical fire return interval is = or \< the length of the observed record for fire 1984-2024.

> To start looking at this, we need the following things.

> 1.  Download the landfire/historical fire regime/ fire return interval product at https://landfire.gov/fire-regime/fri. Map out where historical fire regime is 40 years or less.

> 2.  See what proportion of that area is in forest vs non forest vegetation types using landfire existing vegetation cover (https://landfire.gov/vegetation/evc).

> 3.  Find the best more comprehensive record possible of fire perimeters for 1984-2024. This step will take longer but Mahsa and Jaz are both thinking about it. So we could group up on that piece!

### From Winslow, via Slack, 1/25/2025, in response to first drafts of forest and FRI rasters:

> Hi Lora, \[...\] Now that you have all fire perimeters, I think we are ready to move forward. So heres what I think the next steps are:

> 1.  Take a look at the spatial distribution of fires on the eastern side. I think you may have too much of the great prairies included. We could use the DYNAFFOREST study area raster (I can give it to you) to limit our geographic domain.

> 2.  I like your definition of forest. I'd also like to compare it to the two forest products used by Jennifer Balch's team in the good fire analysis. Mahsa has those.

> 3.  We need to classify where in the study area is grassland and where is shrubland/chapperal.

> 4.  For all places where the landfire FRI is less than 40 years, we next produce a map of fire deficit and surplus by calculating the number of times each cell burned in the observational record, and dividing by its landfire historcal record. on the deficit side and surplus sides it will be a conservative estimate.

> 5.  Then we need to know what the deficit vs surplus is for forests with longer FRIs than the observed record. We can't do that at the pixel scale cuz we need to use space for time substitution. So at the level 3 ecoregion level we calculate the fire rotation by veg type (forest, grassland, shrub) the historical fire rotation is the mean fire return interval. The observed fire rotation is calculated as we calculated fire rotation periods (FRPs), defined as the time it takes to burn an area equal in size to the study area: t/∑ai/A , where t is the time period evaluated, ai is annual area burned in year i, and A is the size of the study area.

> It is from this paper: https://iopscience.iop.org/article/10.1088/1748-9326/acee16/meta

> Bonus: I also want to know how much of the western US forests and shrublands (including Alaska) was historically in a long interval stand replacing fire regime vs low severity frequent fire regime. To do so use the landfire fire regime group (frg_new) IIIA, IvA and IVB (stand replacing) vs IA-IC (frequent fire low severity) from this dataset: https://landfire.gov/fire-regime/frg

### From Winslow, email, 2/11/2025, in response to multi-product forest comparison and first drafts of grass and shrub rasters:

> A few comments here: \[...\] I'm supportive of your classification strategies for veg type.

> I think moving forward, given that our Landfire based classification and LCMS are more conservative in general than the LCPRI, We should do the classification as follows: drop LCPRI. If LCMS and our Landfire based classification agree that a pixel is a given veg type, it is that veg type, drop pixels with disagreement.

> Once you create the final grassland, shrubland, forest raster layers, could you please: Further break forest into dry frequent fire forests, mixed severity fire forest, and long interval stand replacing fire forests by using the following groupings This can be accomplished using the FRG_New variable in the BPS table. Dry frequent fire forests would be group 1 A-1C Mixed severity fire regimes would be group IIIA-IIIB Long interval stand replacing fire forests: IVA-IVB and potentiallly with VA and VB. I want to see how this looks including only the group IV categories alone and when IV and V categories are grouped together. Once I look at those maps, we can make adjustments. Then I'd like you to send the grassland, shrubland, dry frequent fire forests, mixed severity forests, and high severity forest rasters to Mahsa and Crystal for another paper we are working on.

> Then we can keep on keeping on calculating deficit and suprlus as previously discussed.

### And also, same day:

> I'm also thinking about analyses we could do with the pixel level fire deficit info for frequent fire forests once estimates of fire deficit/surplus are produced

> 1.  We could calculate trends in the area in different fire deficits over the observational period

> 2.  We could quantify the drivers of fire deficit/surplus in frequent fire forests as a function of climate (temp/precip/vpd normals), topography (slope, aspect), and human factors (distance to road, urban centers), vegetation type (three relevant classes; grassland/shrubland/frequent fire forests)

> open to additional ideas

> Then at the ecoregion III level that includes all forest types, we could run DYNAFFOREST to compare during the observational period and run the model into the future to determine when different ecoregions cross the threshold from deficit to surplus.

### Notes from meeting with Winslow, 2-21-2025

For fire surplus / deficit: because so much of the forest is in deficit, perhaps we peg deficit to -1 to help it show up better.

Can we judge the completeness of the FRI raster? To see what vegetation types and what historical fire deficit can be calculated.

Forest cover: use the 20% cutoff for forest cover.

For forest by categorized fire severity: it seems important to include V-A and V-B fires, to help pick up western coast and Yellowstone regions (for example). Create the same kind of map for grassland and shrubland to get a sense of how class V varies across those groups.

For grass and shrub comparisons, grass looks pretty good. Shrubs - we are gonna need to include some of the mixed classes. Prepare a map of the LCMS possible shrub classes so we can see their spatial distribution and see what we might want to include.

For long FRI groups, what I have calculated is the contemporary fire regime. Mean FRI on the ecoregion level is equal to the historical fire rotation period. So deficit/surplus is contemporary divided by historical.

Analysis: calculating deficit / surplus for all pixels where FRI \< 40, regardless of vegetation type (exluding developed areas). Subset by veg type by masking out our veg rasters. Then do an equivalent approach at ecoregion level. Ecoregion level total deficit/surplus, then forest deficit/surplus, grassland, shrub.

